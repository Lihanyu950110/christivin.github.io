<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐盛的博客</title>
  <subtitle>起今知行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-16T07:04:46.825Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>徐盛</name>
    <email>544915551@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL学习笔记整理（四）</title>
    <link href="http://yoursite.com/2017/02/16/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/16/MySQL学习笔记整理（四）/</id>
    <published>2017-02-16T04:12:13.000Z</published>
    <updated>2017-07-16T07:04:46.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经讲了怎么去建立索引，对索引的基本操作，这篇讲如果去适当的使用索引。我们先了解索引的优缺点，然后在这个基础上分析使用索引的恰当时机。</p>
  <a id="more"></a>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>&#160; &#160; &#160; &#160;创建索引可以大大提高系统的性能。</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 </li>
</ol>
<p>&#160; &#160; &#160; &#160;也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<h2 id="适合建立索引的情况"><a href="#适合建立索引的情况" class="headerlink" title="适合建立索引的情况"></a>适合建立索引的情况</h2><p>一般来说，应该在这些列上创建索引：</p>
<ol>
<li>在经常需要搜索的列上，可以加快搜索的速度；</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
</ol>
<h2 id="不适合建立索引的情况"><a href="#不适合建立索引的情况" class="headerlink" title="不适合建立索引的情况"></a>不适合建立索引的情况</h2><p>一般来说，不应该创建索引的的这些列具有下列特点：</p>
<ol>
<li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>
<li>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>
</ol>
<p><a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="external">此处为参考链接</a>。</p>
<h2 id="索引的使用分析"><a href="#索引的使用分析" class="headerlink" title="索引的使用分析"></a>索引的使用分析</h2><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>&#160; &#160; &#160; &#160;下图说明利用这个指令出现的每项及其含义：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/explain.png" alt=""></p>
<h3 id="使用索引的几个注意事项"><a href="#使用索引的几个注意事项" class="headerlink" title="使用索引的几个注意事项"></a>使用索引的几个注意事项</h3><p>&#160; &#160; &#160; &#160;我们把dept这张表的deptno列设为主键，然后在把dname和loc列设为复合索引。代码如下：</p>
<pre><code>//添加主键
alter table dept add primary key(deptno);
//  dname 左边的列,loc就是右边的列
alter table dept add index my_ind (dname,loc); 
</code></pre><ol>
<li>说明，如果我们的表中有复合索引(索引作用在多列上)， 此时我们注意:对于创建的多列索引，只要查询条件使用了最左边的列，索引一般就会被使用。<pre><code>explain select * from dept where loc=&apos;aaa&apos;\G；//此处就不会使用到索引
</code></pre></li>
</ol>
<ol>
<li><p>对于使用like的查询，查询如果是  ‘%aaa’ 不会使用到索引,‘aaa%’ 会使用到索引。</p>
<p> explain select * from dept where dname like ‘%aaa’\G</p>
<p> 不能使用索引，即，在like查询时，关键的 ‘关键字’ , 最前面，不能使用 % 或者 _这样的字符.， 如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p>
</li>
<li><p>如果条件中有or，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引, 我们建议大家尽量避免使用or 关键字</p>
<p>select * from dept where dname=’xxx’ or loc=’xx’</p>
<p>select * from dept where dname=’xxx’ or loc=’xx’ or deptno=45</p>
<p>这两个语句执行比较就可以等到结果。</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。(添加时,字符串必须’’), 也就是，如果列是字符串类型，就一定要用 ‘’ 把他包括起来.</p>
</li>
<li><p>如果mysql估计使用全表扫描要比使用索引快，则不使用索引。情况特殊，比如空表或者记录只有一条的时候。</p>
</li>
</ol>
<h3 id="查询索引使用情况"><a href="#查询索引使用情况" class="headerlink" title="查询索引使用情况"></a>查询索引使用情况</h3><p>&#160; &#160; &#160; &#160;如何查看索引使用的情况，就像看缓存命中率一样:</p>
<pre><code>show status like ‘Handler_read%’;
</code></pre><p>tips：</p>
<pre><code>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数。

handler_read_rnd_next:这个值越高，说明查询低效。
</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经讲了怎么去建立索引，对索引的基本操作，这篇讲如果去适当的使用索引。我们先了解索引的优缺点，然后在这个基础上分析使用索引的恰当时机。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql学习" scheme="http://yoursite.com/categories/mysql%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记整理（三）</title>
    <link href="http://yoursite.com/2017/02/15/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/15/MySQL学习笔记整理（三）/</id>
    <published>2017-02-15T05:02:11.000Z</published>
    <updated>2017-07-15T03:55:10.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经建立了测试数据库，然后通过相关工具找到了慢查询的语句，这些就是我们优化的对象，本篇就从索引的角度去改善我们的数据库性能。共四种索引，主键索引、唯一索引、普通索引、全文索引。索引是有消耗的，占空间的，MYI格式文件在data文件夹下。<br>  <a id="more"></a></p>
<p>&#160; &#160; &#160; &#160;<font color="red">索引能使查询变快的原理</font>：先建了一个索引文件，就是MYI文件，然后建立查找二叉树（也叫B树，二叉搜索树，二叉排序树）。利用了二叉树算法，使搜索性能逼近二分查找，但是他比连续内存空间的二分查找优点是，插入和删除不需要移动大量数据，通常是常数开销。记录下了对应索引数值的物理位置，所以数据库换了路径，索引也失效了。</p>
<p>&#160; &#160; &#160; &#160;学会用并利用explain来分析语句。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.png" alt=""></p>
<h2 id="建立适当的索引"><a href="#建立适当的索引" class="headerlink" title="建立适当的索引"></a>建立适当的索引</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>&#160; &#160; &#160; &#160;当一张表，把某个列设为主键的时候，则该列就是主键索引。主键不能为null且不允许重复。</p>
<pre><code>create table aaa
(id int unsigned primary key auto_increment ,
name varchar(32) not null defaul ‘’);
</code></pre><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>&#160; &#160; &#160; &#160;这是id 列就是主键索引。</p>
<p>&#160; &#160; &#160; &#160;如果你创建表时，没有指定主键索引，也可以在创建表后，在添加指令:</p>
<pre><code>alter table 表名 add primary key (列名);
</code></pre><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>&#160; &#160; &#160; &#160;举例:</p>
<pre><code>create table bbb (id int , name varchar(32) not null default ‘’);

alter table bbb add primary key (id);
</code></pre><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>&#160; &#160; &#160; &#160;添加之后发现库文件MYI文件变大。我们在我们测试样本的emp库建立主键索引，且前后查询对比如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; select * from emp where empno=3456789;</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| empno   | ename  | job      | mgr | hiredate   | sal     | comm   | deptno |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| 3456789 | mFmwwU | SALESMAN |   1 | 2017-05-05 | 2000.00 | 400.00 |     82 |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">1 row in set (0.85 sec)</div><div class="line"></div><div class="line">mysql&gt; alter table emp add primary key(empno);</div><div class="line">Query OK, 4000000 rows affected (9.47 sec)</div><div class="line">Records: 4000000  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line">mysql&gt; select * from emp where empno=3456789;</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| empno   | ename  | job      | mgr | hiredate   | sal     | comm   | deptno |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| 3456789 | mFmwwU | SALESMAN |   1 | 2017-05-05 | 2000.00 | 400.00 |     82 |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;发现时间明显变少，这就是主键索引的作用，按主键单位时间定为到准确位置，而不是从头开始找。</p>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>&#160; &#160; &#160; &#160;一般来说，普通索引的创建，是先创建表，然后在创建普通索引。</p>
<p>&#160; &#160; &#160; &#160;比如:</p>
<pre><code>//先建表
create table ccc(
id int unsigned,
name varchar(32)
)
//添加索引
create index 索引名 on 表 (列1,列名2);
</code></pre><h3 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h3><p>&#160; &#160; &#160; &#160;全文索引，主要是在很针对文件、文本的检索、比如文章，全文索引仅针对MyISAM有用。我们在测试样本temp库中创建下表，并插入测试数据如下：</p>
<h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><pre><code>mysql&gt; CREATE TABLE articles (
    -&gt;        id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    -&gt;        title VARCHAR(200),
    -&gt;        body TEXT,
    -&gt;        FULLTEXT (title,body)
    -&gt;      )engine=myisam charset utf8;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; INSERT INTO articles (title,body) VALUES
    -&gt;      (&apos;MySQL Tutorial&apos;,&apos;DBMS stands for DataBase ...&apos;),
    -&gt;      (&apos;How To Use MySQL Well&apos;,&apos;After you went through a ...&apos;),
    -&gt;      (&apos;Optimizing MySQL&apos;,&apos;In this tutorial we will show ...&apos;),
        -&gt;      (&apos;1001 MySQL Tricks&apos;,&apos;1. Never run mysqld as root. 2. ...&apos;),
    -&gt;      (&apos;MySQL vs. YourSQL&apos;,&apos;In the following database comparison ...&apos;),
    -&gt;      (&apos;MySQL Security&apos;,&apos;When configured properly, MySQL ...&apos;);
Query OK, 6 rows affected (0.00 sec)
Records: 6  Duplicates: 0  Warnings: 0
</code></pre><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>然后使用下面命令看是否成功,其中\G代表按行打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; show index from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h4 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h4><p>&#160; &#160; &#160; &#160;使用explain来分析一个错误使用全文索引的语句。</p>
<pre><code>mysql&gt; explain select * from articles where body like &quot;%mysql%&quot;\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: articles
   partitions: NULL
         type: ALL
possible_keys: NULL
      key: NULL
  key_len: NULL
      ref: NULL
     rows: 6
 filtered: 16.67
    Extra: Using where
1 row in set, 1 warning (0.00 sec)
</code></pre><p>可看到possible_keys: NULL，key: NULL，说明没用到，下面例子就看到使用到了title。</p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><font color="red">正确的用法：WHERE  MATCH(title,body) against(‘database’);</font>


<pre><code>mysql&gt; explain select * from articles where match(title,body)     against(&apos;database&apos;)\G; 
*************************** 1. row ***************************
       id: 1
  select_type: SIMPLE
        table: articles
   partitions: NULL
     type: fulltext
possible_keys: title
          key: title
      key_len: 0
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
</code></pre><p>&#160; &#160; &#160; &#160;说明：</p>
<ol>
<li>在mysql中fulltext 索引只针对 myisam生效</li>
<li>mysql自己提供的fulltext针对英文生效-&gt;sphinx (coreseek) 技术处理中文</li>
<li>使用方法是 match(字段名..) against(‘关键字’)</li>
<li>全文索引一个 叫 停止词,  因为在一个文本中，创建索引是一个无穷大的数，因此，对一些常用词和字符，就不会创建，这些词，称为停止词.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; select match(title,body) against(&apos;a&apos;) from articles;</div><div class="line">+--------------------------------+</div><div class="line">| match(title,body) against(&apos;a&apos;) |</div><div class="line">+--------------------------------+</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">+--------------------------------+</div><div class="line">6 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>&#160; &#160; &#160; &#160;当表的某列被指定为unique约束时，这列就是一个唯一索引。按照以下方式建表，name列就是唯一索引。<font color="red">唯一索引允许为空，而且允许多个。</font></p>
<h4 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h4><pre><code>mysql&gt; create table ddd(id int primary key auto_increment , name varchar(32)     unique);
Query OK, 0 rows affected (0.02 sec)
</code></pre><h4 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h4><p>&#160; &#160; &#160; &#160;在创建表后，再去创建唯一索引，见如下指令：</p>
<pre><code>create table eee(id int primary key auto_increment, name varchar(32));

create unique index 索引名  on 表名 (列表..);
</code></pre><h2 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h2><p>desc 表名 【该方法的缺点是：　不能够显示索引名.】</p>
<p>show index(es) from 表名</p>
<p>show keys from 表名</p>
<h4 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; desc articles</div><div class="line">    -&gt; ;</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">| Field | Type             | Null | Key | Default | Extra          |</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |</div><div class="line">| title | varchar(200)     | YES  | MUL | NULL    |                |</div><div class="line">| body  | text             | YES  |     | NULL    |                |</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; show index from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line">ERROR: </div><div class="line">No query specified</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; show keys from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>alter table 表名 drop index 索引名; </p>
<p>如果删除主键索引。</p>
<p>alter table 表名 drop primary key </p>
<h2 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h2><p>先删除再重新创建。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节介绍的如何操作索引和索引能加快查询的原理。下篇我们看看怎么去分析索引的性能，比如explain用法，然后我们该怎么去适用索引最恰当。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经建立了测试数据库，然后通过相关工具找到了慢查询的语句，这些就是我们优化的对象，本篇就从索引的角度去改善我们的数据库性能。共四种索引，主键索引、唯一索引、普通索引、全文索引。索引是有消耗的，占空间的，MYI格式文件在data文件夹下。&lt;br&gt;
    
    </summary>
    
      <category term="mysql学习" scheme="http://yoursite.com/categories/mysql%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记整理（二）</title>
    <link href="http://yoursite.com/2017/02/14/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/14/MySQL学习笔记整理（二）/</id>
    <published>2017-02-14T02:08:23.000Z</published>
    <updated>2017-07-15T03:51:08.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;之前已经了解过mysql的基本原理，重点是我们该从哪些方面去改善数据库性能，或者从设计开始怎么样去合适的设计，可以使用哪些工具和方法去帮助我们监测数据库，并根据在数据库原理的理解基础上，对不同的业务需求不同的软硬件环境，尽量做出最优的优化策略。下面就看下有哪些优化方法和适用场景，可以根据实际选用其中一部分进行优化，而且优化是一个整体的，所以不是改变一个方法就能大幅提升性能，也没有确定的套路。本文在看了传智mysql优化课程之后记录的学习笔记。</p>
  <a id="more"></a>
<h2 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h2><p>对mysql优化时一个综合性的技术，主要包括：</p>
<ol>
<li><p>表的设计合理化(符合3NF)</p>
</li>
<li><p>添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引]</p>
</li>
<li>分表技术(水平分割、垂直分割)</li>
<li>读写[写: update/delete/add]分离</li>
<li>存储过程 [模块化编程，可以提高速度]</li>
<li>对mysql配置优化 [配置最大并发数my.ini, 调整缓存大小 ]</li>
<li>mysql服务器硬件升级</li>
<li>定时的去清除不需要的数据,定时进行碎片整理(MyISAM) </li>
</ol>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>表的范式，是首先符合1NF, 才能满足2NF , 进一步满足3NF</p>
<p>&#160; &#160; &#160; &#160;1NF: 即表的列的具有原子性,不可再分解，即列的信息，不能分解, 只有数据库是关系型数据库(mysql/oracle/db2/informix/sysbase/sql server)，就自动的满足1NF。</p>
<p>&#160; &#160; &#160; &#160;2NF: 表中的记录是唯一的, 就满足2NF, 通常我们设计一个主键来实现。</p>
<p>&#160; &#160; &#160; &#160;3NF: 即表中不要有冗余数据, 就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放. 比如下面的设计就是不满足3NF:</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/3NF.png" alt=""></p>
<p>需要修改成以下，消除依赖：<br><img src="http://opb7t58xj.bkt.clouddn.com/3NF2.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;反3NF : 但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。 </p>
<p>案例 ：<br><img src="http://opb7t58xj.bkt.clouddn.com/%E5%8F%8D3NF.png" alt=""></p>
<h3 id="show-status"><a href="#show-status" class="headerlink" title="show status"></a>show status</h3><p>&#160; &#160; &#160; &#160;查看mysql配置参数。我的运行环境是Mac，mysql5.7.18，如下图：<br><img src="http://opb7t58xj.bkt.clouddn.com/showstatus.png" alt=""><br>从图中可知，有356个变量，其中我们需要熟悉一部分，知道它代表的意义，可用下面指令查具体的：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/show%20like.png" alt=""></p>
<p>注意：这里结束符非常重要，区分中英文符号，是结束一条命令的标志。。。。。存储过程中还要改。因为存储过程中就有分号。</p>
<p>这里放两个链接：<a href="http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html" target="_blank" rel="external">mysql 命令大全</a>，<a href="http://blog.itpub.net/15480802/viewspace-764968/" target="_blank" rel="external">mysql较为重要的状态变量</a>。</p>
<p>&#160; &#160; &#160; &#160;那我们如何从一个大项目中，迅速的定位执行速度慢的语句. (定位慢查询)，比如首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)。实现如下：</p>
<p><em>show status</em></p>
<ol>
<li><p>常用的:<br>show status like ‘uptime’ ;<br>show  stauts like ‘com_select’  show stauts like ‘com_insert’ …类推 update  delete</p>
</li>
<li><p>show [session|global] status like …. 如果你不写  [session|global] 默认是session 会话，指取出当前窗口的执行，如果你想看所有(从mysql 启动到现在，则应该 global)</p>
</li>
<li><p>show status like ‘connections’; </p>
</li>
<li><p>show status like ‘slow_queries’;//显示慢查询次数</p>
</li>
</ol>
<h3 id="压力测试脚本生成"><a href="#压力测试脚本生成" class="headerlink" title="压力测试脚本生成"></a>压力测试脚本生成</h3><p>&#160; &#160; &#160; &#160;如何去定位慢查询呢，我们想还原一个场景，那我们就要构建一个大表(400 万)，我们采用存储过程构建，默认情况下，mysql认为10秒才是一个慢查询.所以我们要修改mysql的慢查询时间.使用以下命令：</p>
<p>show variables like ‘long_query_time’ ; //可以显示当前慢查询时间</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/60AEBD45-4A1C-4709-90F9-04324FBB4197.png" alt=""></p>
<p>set long_query_time=1 ;//可以修改慢查询时间</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/manchaxun.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;而且我们构建的大表中记录是有要求的,为了满足真实性，我们采取了随机生成的方法 ，使记录不同从而使测试效果和真实的相差不大。存储过程源码我放在了GitHub上，地址如下，无耻的求个star或者fork：<a href="https://github.com/wustzoujing/BetterMysqlTestDemo" target="_blank" rel="external">wustzoujing/BetterMysqlTestDemo</a>；简要的记录下我的执行过程；<br>首先写了两个随机函数，产生指定长度的两个字符串或者数字。其中rand_string()执行结果如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;上图可以知道：其中dual是亚元表，就是空表，已经随机生成了6位字符串。接下来看看存储过程执行成功如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/cunshuguochen.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;最后我们调用存储过程，执行几分钟后，看下结果，已经插入成功。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/shuju.png" alt=""></p>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>这时我们已经有慢查询的次数了，就是插入数据这条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;long_query_time&apos;</div><div class="line"></div><div class="line">    -&gt; ;</div><div class="line">    </div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">| Variable_name   | Value    |</div><div class="line"></div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">| long_query_time | 1.000000 |</div><div class="line"></div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">1 row in set (0.01 sec)</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;然后我们需要开启慢查询日志（不同操作系统不同设置方式和文件路径，百度应该有很多），然后重启mysql，上面就会记录着我们的慢查询语句是什么。如下图，这是我的结果。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-05%20%E4%B8%8B%E5%8D%885.16.25.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;这里我们主要是形成测试样本，利用慢查询工具，这只是一个例子，还有很多命令方法工具帮助我们来找出问题，可以参考手册来。下篇博客讲讲发现问题了，我们如何优化。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;之前已经了解过mysql的基本原理，重点是我们该从哪些方面去改善数据库性能，或者从设计开始怎么样去合适的设计，可以使用哪些工具和方法去帮助我们监测数据库，并根据在数据库原理的理解基础上，对不同的业务需求不同的软硬件环境，尽量做出最优的优化策略。下面就看下有哪些优化方法和适用场景，可以根据实际选用其中一部分进行优化，而且优化是一个整体的，所以不是改变一个方法就能大幅提升性能，也没有确定的套路。本文在看了传智mysql优化课程之后记录的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql学习" scheme="http://yoursite.com/categories/mysql%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记整理（一）</title>
    <link href="http://yoursite.com/2017/02/13/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/13/MySQL学习笔记整理（一）/</id>
    <published>2017-02-13T03:08:56.000Z</published>
    <updated>2017-07-13T03:13:13.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;数据库是后台开发重中之重的一个环节，了解当前各种类型的数据库，并在了解各种数据库设计原理的基础上，深入学习相关优化策略，加之以实战经验，才是长久的发展之计。之后对先对关系型数据库–mysql为例进行深入学习笔记记录，毕竟开源，而且也是世界顶级的数据库，然后对非关系型数据库NoSql进行学习，以Redis为例，这些都已经接触过了，之后将做一个总结的笔记。</p>
  <a id="more"></a>
<h2 id="数据库的种类"><a href="#数据库的种类" class="headerlink" title="数据库的种类"></a>数据库的种类</h2><ol>
<li>对象数据库 应用领域：地理信息系统、科学与统计数据库、多媒体系统、XML文档仓库。</li>
<li>对象关系数据库 了解一下</li>
<li>关系数据库，例如mysql、oracle、sql server、db2等。我们以mysql为例深入了解关系数据库。</li>
<li>介于关系数据库与非关系数据库之间的MongoDB和完全的非关系数据库NoSql的Redis。Redis是我们了解的重点。</li>
</ol>
<h2 id="mysql数据库系统"><a href="#mysql数据库系统" class="headerlink" title="mysql数据库系统"></a>mysql数据库系统</h2><p>&#160; &#160; &#160; &#160;mysql由SQL接口、解析器、查询优化器、查询缓存（缓存和缓冲区）、存储引擎等几个子系统构成。</p>
<p><img src="http://img1.51cto.com/attachment/201308/111054362.png?_=3641983" alt=""></p>
<p>&#160; &#160; &#160; &#160;图中还有几个部分解释如下：</p>
<p>connectors：与其他编程语言中的sql 语句进行交互，如php、java等；</p>
<p>Management Serveices &amp; Utilities：系统管理和控制工具；</p>
<p>Connection Pool (连接池)：管理缓冲用户连接，线程处理等需要缓存的需求。下面我们一个一个的来了解。</p>
<h3 id="SQL接口"><a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h3><p>&#160; &#160; &#160; &#160;SQL提供了从用户接收命令并把结果返回给用户的机制。关系数据库大都支持SQL标准，基本语句都类似，比如常规的CURD操作，sql server和mysql就差不多。mysql是一个多线程应用，它为每一个连接创建一个线程，每个线程执行都独立于其他线程。接收到SQL命令，解析各个部分存入一个类结构，查询结果通过有关数据写到网络通信协议上传输给客户端。</p>
<h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器使用Lex和YACC实现，它能够把一条SQL语句分解为命令字、选项和参数等一系列最基本的语法元素，并将这些存入一个Lex类的结构中，后面查询步骤都会使用这个。规则使用Lex和YACC编写，在使用Bison编译成一个词法解析器。</p>
<h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>&#160; &#160; &#160; &#160;查询优化策略有很多，也可以设计优化算法，高阶程序员也可以自己写查询优化器代替mysql默认的。sql server使用的查询优化策略是基于开销的，根据一系列等价规则为给定查询生成一系列查询评估计划，然后根据关于执行这个查询所需要的关系和操作性能指标数据中选出开销最小的。mysql是混合使用多种优化技术的数据库系统，围绕着选取-投影-联结策略而设计出来的，从整体上能保证生成好的，但不能保证生成最好的查询语句。属于启发式查询优化机制。</p>
<p>&#160; &#160; &#160; &#160;具体的 <strong>选取-投影-联结</strong> 策略 ：即先更具有关的限制条件进行选取（select操作）以减少要处理的元组个数，再进行投影以减少被选取元组里的属性字段的个数，最后根据联结条件生成最终的查询结果。</p>
<ol>
<li>通过计算where子句里的表达式来横向排除多余的数据。</li>
<li>只保留在属性清单里面列出来的，以及在最后执行连接子句时还需要用到的属性字段，其他数据全部排除。</li>
<li>根据联结条件生成最终的查询结果。</li>
</ol>
<p>&#160; &#160; &#160; &#160;优化的第一步检查有关的表是否存在以及用户的访问权限。发现错误返回出错信息并把控制器交给线程管理器，也就是负责监听请求的listener，一旦找到了正确的表，就打开并应用适当的并发控制。<br>&#160; &#160; &#160; &#160;所有的维护和初识化任务完成后，优化器将利用Lex结构对命令中where条件进行处理，其结果作为临时表返回后续步骤做一步处理。如果查询命令里面有UNION操作法，优化器将以循环方式执行完所有的select操作之后再进行下一步。<br>&#160; &#160; &#160; &#160;优化器下一步时执行投影操作。这一步中间结果保存在临时表中且只保存指定列。最后检查Lex结构是否含有Join条件；如果有，调用join优化方法。</p>
<p>&#160; &#160; &#160; &#160;优化内容：对条件表达式进行简化和求值，消除死分支或恒真恒假条件。总之，在执行联结操作之前，优化器会尽量减小查询命令里的条件。</p>
<h3 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h3><p>&#160; &#160; &#160; &#160;查询的具体执行是由一组库方法实现，每种方法复制一种特点操作，例如CRUD。方法都有一个线程对象参数，可以让那些方法直接找到合线程访问相关的内部查询结构，加快执行速度。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>&#160; &#160; &#160; &#160;查询缓存，包括查询语句解析结果和查询结果本身。把频率最高的数据放在内存中能够快速的访问来加快。速度。mysql把数据封装成某个结构（不同对象缓存，用来封装的结构不同），再把数据保存为一个链表。缓存友表缓存（为了减少打开读取和关闭表，frm文件）、记录缓存（减少数据读写频率）、键缓存（缓存各索引的热度）、权限缓存（授权信息，存为先进后出的散列表）、主机名缓存（用栈）、其他类似联结缓存。缓存有自己的监控机制，利用LRU最近最少使用页面靠换策略。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>&#160; &#160; &#160; &#160;这个是重要的一环，也是mysql最佳功能之一。数据库使用者可以根据需求选择不同的存储引擎，存储引擎是关键的一部，也是数据库管理系统最底层的一个，直接与数据库文件进行交互，也就是对数据库进行IO操作。下面介绍mysql提供的一些存储引擎。</p>
<ol>
<li>MyISAM 是默认的存储引擎，它在ISAM上增加了一些新的缓存和索引机制。为了提高访问速度，这类表还普遍使用了数据压缩和索引优化技术。<font color="red">此外还准备了表级的锁定机制。所以适合检索读性能。</font></li>
<li>InnoDB 几乎总是用在需要支持事务的应用程序。支持ACID，InnoDB所有索引采用B-树结构，放在叶子节点里。改进了并发控制，提供行级的锁定。所以对频繁更新，添加，删除等类型数据库是首选存储引擎。</li>
<li>BDB提供页面即的锁。支持散列表、B-树。</li>
<li>内存存储引擎。HEAP表。</li>
<li>合并存储引擎。安装特定规则分成很多小表去存储一个大表，搜索的时候可以去搜索特定的小表而不是搜索体积庞大的大表。但是缺点是：只能用相同的myisam表，不允许替换操作，与普通表相比，使用索引访问效率要低。</li>
<li>档案。把大量数据保存为压缩格式，适合存放和检索那些不需要频繁更新的档案性或历史积累数据。比如系统日志。</li>
<li>联合存储引擎。适合用在分布式环境</li>
<li>群集／NDB 。 在一个高可用性和高性能的环境中使用多个mysql服务器提供数据库服务。</li>
<li>其他的包括：CSV、黑洞、定制的。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;了解了一下数据库的类型，和mysql的组成，对RDBS的设计有了大致的了解，那么后面将对在此基础上对mysql优化进行一个深度的学习和总结，并找demo来实战。下面对SQL 语句执行过程进行说明：</p>
<p>   &#160; &#160; &#160; &#160;数据库通常不会被直接使用，而是由其他编程语言通过SQL语句调用mysql，由mysql处理并返回执行结果。那么Mysql接受到SQL语句后，又是如何处理的呢？</p>
<p>   &#160; &#160; &#160; &#160;首先程序的请求会通过mysql的connectors与其进行交互，请求到处后，会暂时存放在连接池（connection pool)中并由处理器（Management Serveices&amp;Utilities）管理。当该请求从等待队列进入到处理队列，管理器会将该请求丢给SQL接口（SQL Interface）。SQL接口接收到请求后，它会将请求进行hash处理并与缓存中的结果进行对比，如果完全匹配则通过缓存直接返回处理结果；否则，需要完整的走一趟流程：</p>
<ol>
<li><p>由SQL接口丢给后面的解释器（Parser），上面已经说到，解释器会判断SQL语句正确与否，若正确则将其转化为数据结构。</p>
</li>
<li><p>解释器处理完，便来到后面的优化器（Optimizer），它会产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果。</p>
</li>
<li><p>确定最优执行计划后，SQL语句此时便可以交由存储引擎（Engine）处理，存储引擎将会到后端的存储设备中取得相应的数据，并原路返回给程序。</p>
</li>
<li><p>这里有几点需要注意：</p>
</li>
</ol>
<p>&#160; &#160; &#160; &#160;(1)如何缓存查询数据？</p>
<p>&#160; &#160; &#160; &#160;存储引擎处理完数据，并将其返回给程序的同时，它还会将一份数据保留在缓存中，以便更快速的处理下一次相同的请求。具体情况是，mysql会将查询的语句、执行结果等进行hash，并保留在cache中，等待下次查询。</p>
<p>&#160; &#160; &#160; &#160;(2)buffer与cache的区别？</p>
<p>&#160; &#160; &#160; &#160;从上面的图可以看到，缓存那里实际上有buffer和cache两个，那它们之间是否有什么不同呢？简单的说就是，buffer是写缓存，cache是读缓存。</p>
<p>&#160; &#160; &#160; &#160;(3)如何判断缓存中是否已缓存需要的数据</p>
<p>&#160; &#160; &#160; &#160;这里可能有一个误区，觉得处理SQL语句的时候，为了判断是否已缓存查询结果，会将整个流程走一遍，取得执行结果后再与需要的进行对比，看看是否命中，并以此说，既然不管缓存中有没有缓存到查询内容，都要整个流程走一遍，那么缓存的优势又在哪里？？</p>
<p>&#160; &#160; &#160; &#160;实际上，并非如此，在第一次查询后，mysql便将查询语句以及查询结果进行hash处理并保留在缓存中，SQL查询到达之后，对其进行同样的hash处理后，将两个hash值进行对照，如果一样，则命中，从缓存中返回查询结果；否则，需要整个流程走一遍。</p>
<p>链接参考：<a href="http://pmghong.blog.51cto.com/3221425/1281970" target="_blank" rel="external">mysql原理</a></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;数据库是后台开发重中之重的一个环节，了解当前各种类型的数据库，并在了解各种数据库设计原理的基础上，深入学习相关优化策略，加之以实战经验，才是长久的发展之计。之后对先对关系型数据库–mysql为例进行深入学习笔记记录，毕竟开源，而且也是世界顶级的数据库，然后对非关系型数据库NoSql进行学习，以Redis为例，这些都已经接触过了，之后将做一个总结的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql学习" scheme="http://yoursite.com/categories/mysql%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机（五）</title>
    <link href="http://yoursite.com/2017/01/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/07/深入理解JAVA虚拟机（五）/</id>
    <published>2017-01-07T01:12:34.000Z</published>
    <updated>2017-07-13T03:04:59.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;我们已经了解了Class文件存储格式的具体细节，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。<font color="red">而虚拟机如何加载这些Class文件？这些信息进入到虚拟机后会发生什么变化？</font>。这是我们接下来要学习的内容。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;虚拟机把描述类的数据从calss文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<font color="red">与那些在编译期需要进行连接的工作语言不同，在Java语言里，类加载荷连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为程序提供高度的灵活性</font>，动态扩展的特性也就是依赖运行期间动态加载和动态连接这个特点实现的。如面向接口的编程。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>&#160; &#160; &#160; &#160;类从加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期共包含七个阶段，如下图：</p>
<p>&#160; &#160; &#160; &#160;<img src="http://img.blog.csdn.net/20140105211344671" alt=""></p>
<p>&#160; &#160; &#160; &#160;其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h3 id="初始化规范"><a href="#初始化规范" class="headerlink" title="初始化规范"></a>初始化规范</h3><p>&#160; &#160; &#160; &#160;虚拟机规范中堆什么情况需要开始类加载的第一个阶段，加载并没有强制约束，但是对初始化阶段，规范了有且只有4种情况必须立即对类进行初始化。</p>
<ol>
<li>遇到new、getstatic、putstatic或者invokestatic这4条字节码指令时（比如在使用new创建对象的时候，读取或设置一个类静态字段、调用一个类的静态方法）</li>
<li>使用java.lang.relect包的方法对类进行反射调用的时候，如果类没有进行初始化，首先出发初始化。</li>
<li>当初始化一个类，发现父类还没有进行初始化，先出发父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的哪个类），虚拟机会先初始化这个主类。</li>
</ol>
<p>&#160; &#160; &#160; &#160;以上四种是对类的主动引用，下面说几种被动引用：</p>
<ol>
<li>通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</li>
<li>一个类的成员进入常量池，另一个类引用只是对常量池的引用，两个class就无关了。</li>
<li>接口加载和类加载稍微有点不同，只有真正使用到父接口的时候才会初始化。</li>
</ol>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>&#160; &#160; &#160; &#160;接下来讲解一下类加载的全过程，也就是加载、验证、准备、解析和初始化这五个过程。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法去访问数据的访问入口。</li>
</ol>
<p>&#160; &#160; &#160; &#160;正是因为没有指明具体的从哪获取，怎么获取，所以充满活力的开发前辈玩出了很多花样：</p>
<ol>
<li>从zip包中读取，最后成为jar，EAR，WAR格式的基础。</li>
<li>从网络中获取，比如Applet</li>
<li>从计算机运行生成，比如动态代理</li>
<li>其他文件，比如JSP</li>
<li>从数据库读取，有些中间件服务器可以把程序安装到数据库中来完成程序代码在集群间的分发。</li>
</ol>
<p>&#160; &#160; &#160; &#160;相对其他过程，加载是开发期可控性最强的阶段。可以使用系统的加载器，也可以自定义类加载器。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol>
<li>文件格式验证；比如魔数、主次版本号；常量池是否含有不支持的常量类型；等等。。。经过验证才会进入内存的方法区进行存储。所以下面的几个验证阶段全部都是基于方法区的存储结构进行的。</li>
</ol>
<ol>
<li>元数据验证；验证点比如：这个类是否有父类，父亲是否成常量不允许基础的类，如果这个类不是抽象类，是否实现了父类或接口之中要求实现的索引方法，类中的字段、方法是否和父类产生了矛盾等。这一阶段主要进行语义检验，保证不存在不符合Java语言规范的元数据信息。</li>
</ol>
<ol>
<li><p>字节码检验；是最复杂的的一个阶段，主要工作是进行数据流和控制流分析。在第二个阶段堆数据类型做完校验之后，这阶段对类的方法体进行校验分析。比如：保证任何时刻操作数类型和指令码序列都能配合工作、保证跳转指令不会跳转到方法体以外的字节码指令、保证类型转换时有效的。如果通过不一定安全，不通过一定不安全。</p>
</li>
<li><p>符号引用；对类自身以外的信息进行匹配性校验。比如：全限定名能否找到该类，指定类中是否存在符合方法的字段描述符。</p>
</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>&#160; &#160; &#160; &#160;此阶段时正式为类变量（ 不包括实例变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配，</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>&#160; &#160; &#160; &#160;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法四类符号引用。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>&#160; &#160; &#160; &#160;对类的静态变量，静态代码块执行初始化操作。</p>
<p>参考这边博文：<a href="http://www.cnblogs.com/ITtangtang/p/3978102.html" target="_blank" rel="external">类加载机制及反射</a>。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>&#160; &#160; &#160; &#160;虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，实现这个动作的代码块称为类加载器。它在Java Applet、类层次划分、OSGi、热部署、代码加密等领域大放异彩。</p>
<p>&#160; &#160; &#160; &#160;对任意一个类都需要由加载它的类加载器和这个类本身一同确定它在虚拟机中的唯一性。对虚拟机里来说只有两种不同的类加载器，一种是启动类加载器由C++实现，另一种就是Java写的，都继承java.lang.ClassLoader。对于开发人员来说它还进一步分为扩展类的和应用程序类的加载器。分别加载／lib/etc目录下的，和calsspath用户路径下的。</p>
<p><img src="http://img.my.csdn.net/uploads/201009/25/0_1285421756PHyZ.gif" alt=""></p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>&#160; &#160; &#160; &#160;工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。在classload的loadclass（）方法中实现。</p>
<p>&#160; &#160; &#160; &#160;好处：java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;我们已经了解了Class文件存储格式的具体细节，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能被运行和使用。&lt;font color=&quot;red&quot;&gt;而虚拟机如何加载这些Class文件？这些信息进入到虚拟机后会发生什么变化？&lt;/font&gt;。这是我们接下来要学习的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="类加载机制" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机（四）</title>
    <link href="http://yoursite.com/2017/01/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/06/深入理解JAVA虚拟机（四）/</id>
    <published>2017-01-06T14:23:17.000Z</published>
    <updated>2017-07-11T08:42:01.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;以前计算机程序课上老师总说：计算机只认识0和1，写的程序都会编译成为0和1组成的二进制格式才能被计算机执行。然而10多年的时间过去了，今天的计算机仍然只能识别0和1，但是建立在虚拟机之上的大量程序语言发展迅速，将2我们编写的程序编译成二进制本地机器码（native code）已不再是唯一的选择，<font color="red">越来越多的程序语言选择了与操作系统和机器指令无关平台中立的格式作为程序编译之后的存储格式</font>。这也是Java这类语言，平台无关性的基石。而且虚拟机上更有语言无关性的趋势。</p>
<a id="more"></a>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>&#160; &#160; &#160; &#160;Class文件是一组以8位字节为基础的二进制，各个数据项目严格按照顺序紧凑的排列Class文件之间，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据。</p>
<p>&#160; &#160; &#160; &#160;虚拟机规范：Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中还有两种数据结构：无符号和表，后面的解析都要以这两种数据类型为基础。</p>
<p>&#160; &#160; &#160; &#160;无符号数属于基本的数据类型，用u1,u2,u4,u8分别代表1个字节、2个字节、4个字节、8个字节的无符号数，可以用来描述数字、索引引用、数量值，或者按照UTF-8编码构成字符串值。</p>
<p>&#160; &#160; &#160; &#160;表是由多个无符号数或其他数据项构成的复合结构数据，整个class文件本质上就是一张表。</p>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>&#160; &#160; &#160; &#160;每个class文件的头四个字节被称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多图片格式在文件头都有魔数。Java中为：0XCAFFBABE；</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>&#160; &#160; &#160; &#160;紧接着4个字节存储的是Class文件的版本号：5-6是次版本，7-8是主版本。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>&#160; &#160; &#160; &#160;主次版本号之后是常量池的入口，也是与其他项目关联最多的数据类型，也是占用class文件空间最大的项目之一，同时还是第一个出现的表类型。主要存放字面量和引用。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>&#160; &#160; &#160; &#160;在常量池之后，紧接2个字节代表访问标志，包括是接口还是类，是否public，abstract，final等等。</p>
<h3 id="类索引、父亲索引与接口索引集合"><a href="#类索引、父亲索引与接口索引集合" class="headerlink" title="类索引、父亲索引与接口索引集合"></a>类索引、父亲索引与接口索引集合</h3><p>&#160; &#160; &#160; &#160;类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据集合。类确定了这个类的全限定名，父亲索引确定这个父类的全限定名。不允许多继承，所以父类索引直邮一个。除了object都有父类。接口索引表示这个类实现了哪些接口。</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>&#160; &#160; &#160; &#160;字段表用于描述接口或类中声明的变量</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>&#160; &#160; &#160; &#160;访问标志、名称索引、描述符索引都表达清楚了，方法里面的代码经过编译器编译成字节码指令之后，存放在方法属性表集合中一个名为code的属性里面，属性表作为class文件格式最具扩展性的一种数据项目。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>&#160; &#160; &#160; &#160;class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<h2 id="class文件结构的发展"><a href="#class文件结构的发展" class="headerlink" title="class文件结构的发展"></a>class文件结构的发展</h2><p>&#160; &#160; &#160; &#160;上面这些属性大部分都用于支持Java中许多新出现的语言特性，如枚举、变长参数、泛型、动态注解。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;class文件是Java虚拟机执行引擎的数据入口，也是技术体系的基础支柱之一。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;以前计算机程序课上老师总说：计算机只认识0和1，写的程序都会编译成为0和1组成的二进制格式才能被计算机执行。然而10多年的时间过去了，今天的计算机仍然只能识别0和1，但是建立在虚拟机之上的大量程序语言发展迅速，将2我们编写的程序编译成二进制本地机器码（native code）已不再是唯一的选择，&lt;font color=&quot;red&quot;&gt;越来越多的程序语言选择了与操作系统和机器指令无关平台中立的格式作为程序编译之后的存储格式&lt;/font&gt;。这也是Java这类语言，平台无关性的基石。而且虚拟机上更有语言无关性的趋势。&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="文件结构" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机（三）</title>
    <link href="http://yoursite.com/2017/01/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/05/深入理解JAVA虚拟机（三）/</id>
    <published>2017-01-05T02:23:17.000Z</published>
    <updated>2017-07-11T08:37:16.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在了解了Java运行时内存区域之后，我们知道虚拟机可能造成内存溢出OOM，虽然有垃圾回收机制，但是可能也不能避免，<font color="red">我们现在就看看Java的垃圾收集机制为例避免内存溢出异常已经做出了哪些努力。</font></p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说起GC，我们需要做下面三件事情：</p>
<ol>
<li>哪些内存需要回收？</li>
<li>何时回收？</li>
<li>如何回收？</li>
</ol>
<p>&#160; &#160; &#160; &#160;现在内存的动态分配、垃圾回收技术已经相当的成熟，那我们为什么还要去学习内存分配和GC呢？答案：<font color="red">当需要排查各种OOM问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我就需要对自动化的技术实施必要的监控和调节。</font></p>
<h2 id="怎么判断对象已死？"><a href="#怎么判断对象已死？" class="headerlink" title="怎么判断对象已死？"></a>怎么判断对象已死？</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>&#160; &#160; &#160; &#160;给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1；失效就减1；任何时刻为0的对象就是不可能再被使用的。</p>
<p>&#160; &#160; &#160; &#160;缺点：不能解决循环引用的问题。</p>
<h3 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h3><p>&#160; &#160; &#160; &#160;Java和C#所采用的方式，基本原理：通过一系列名为GC Roots的对象为起点，从这些根节点向下搜索，走过的路径叫引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的。</p>
<p>&#160; &#160; &#160; &#160;Java语言中可作为GC Roots的对象包括：虚拟机栈中（本地变量表）引用的对象、方法区中的类静态属性引用的对象、方法区中的常量引用对象、本地方法栈中JNI，native方法引用的对象。</p>
<h2 id="引用的几个类型"><a href="#引用的几个类型" class="headerlink" title="引用的几个类型"></a>引用的几个类型</h2><p>&#160; &#160; &#160; &#160;无论是哪种方式，判断存活都与引用有关。引用概念在JDK1.2之后进行了扩充，包括四种：</p>
<ol>
<li>强引用；只要引用存在，垃圾回收器永远不会回收。</li>
<li>软引用；系统将要发生内存溢出之前，会把这些对象列进回收范围并进行第二次回收。如果还不够菜抛出异常。</li>
<li>弱引用；只能存活到下一次垃圾回收发生之前。</li>
<li>虚引用；一个对象是否有虚引用的存在，完全不会对其生命时间构成影响，也无法通过虚引用来获得实例，完全只是为了希望在对这个回收时收到一个系统通知。</li>
</ol>
<h2 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h2><p>&#160; &#160; &#160; &#160;根搜索算法不可达的对象也并不是一定被回收，这时候它处于缓刑阶段。至少要经历两次标记过程。如果发现没有引用链，那么标记一次并且进行一次筛选，条件是对象是否有必要执行finalize（），当对象没有覆盖finalize方法，或者已经被虚拟机调用过，都是为没有必要执行。</p>
<p>&#160; &#160; &#160; &#160;如果判断为有必要执行，就会放置在一个F-Queue队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalize线程区执行。但是并不承诺等待它运行结束，原因是：如果一个对象的finalize方法执行缓慢或者死循环了，其他对象将出现永久等待。</p>
<p>&#160; &#160; &#160; &#160;finalize（）是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次标记，如果对象在finalize中拯救自己—只要重新与引用链上的任何一个对象相连即可。只能自救一次，因为finalize最多使用一次。</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>&#160; &#160; &#160; &#160;主要回收内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象类似。</p>
<p>&#160; &#160; &#160; &#160;判断无用的类得满足下面三个条件：</p>
<ol>
<li>加载该类的加载器已被回收</li>
<li>所有类的实例已经被回收</li>
<li>该类的java.lang.Class对象没有任何地方引用，无法反射得到。</li>
</ol>
<p>满足了也不一定回收，常用的参数如下：</p>
<ol>
<li>-verbose：class</li>
<li>-xx：+TraceClassLoading</li>
<li>-XX：+TraceClassUnLoding</li>
</ol>
<p>&#160; &#160; &#160; &#160;在大量使用反射、动态代理、CGLib等bytecode框架的时候，以及JSP、OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>&#160; &#160; &#160; &#160;首先标记出所有需要回收的对象，在标记完之后统一回收。</p>
<p>&#160; &#160; &#160; &#160;缺点：效率低，产生的碎片多。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>&#160; &#160; &#160; &#160;他将可用的内存划分为等大小的两块，每次只使用其中一块，当用完了，把存活的对象都复制到另一半上，然后把第一块的一次性清理。</p>
<p>缺点：内存利用率低</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>&#160; &#160; &#160; &#160;让所有存活的对象都向一端移动，然后直接清楚掉端边界以外的内存。</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>&#160; &#160; &#160; &#160;当前商业虚拟机都常用分代收集算法，更具对象的存活周期的不同将内存划分为几块，一般是新生代和老年代，这样就可以根据各个年代的特点采用最适当的<strong>收集算法</strong>。在新生代中，每次都有大批对象死去，只有少量的存活，那就选用复制算法。（复制的内容比较少，复制少量存活对象成本），而老年代中因为对象存活率高，就必须使用标记-清理或者标记-整理。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>&#160; &#160; &#160; &#160;包含的收集器如下：<br><img src="http://img.my.csdn.net/uploads/201210/03/1349278110_8410.jpg" alt=""></p>
<h3 id="serial"><a href="#serial" class="headerlink" title="serial"></a>serial</h3><p>&#160; &#160; &#160; &#160;单线程收集器，垃圾收集时，必须暂停所有工作线程。“Stop The World”。</p>
<p>优势：简单而高效，没有线程切换，在客户端模式是个很好选择。</p>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>&#160; &#160; &#160; &#160;是Serial的多线程版本（在新生代垃圾回收的时候采用多GC线程），是服务器模式下首选的新生代收集器，目前只有它能与CMS收集器配合工作。但是作为老年代的收集器，却无法和Parallel Scavenge配合工作。</p>
<p>&#160; &#160; &#160; &#160;它在单核环境中绝对不会比serial效果好，多核也不能百分之百比serial好。</p>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-10.png" alt=""></p>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>&#160; &#160; &#160; &#160;是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器，特别之处是它注重达到一个可控制的吞吐量，可通过设置参数来完成。</p>
<h3 id="serial-Old"><a href="#serial-Old" class="headerlink" title="serial Old"></a>serial Old</h3><p>&#160; &#160; &#160; &#160;是serial的老年代版本，采用的是标记-整理算法。主要意义是客户端模式下使用。如果使用在服务器模式下，主要有两个用途：搭配Parallel Scavenge使用，或者作为CMS收集器的后备预案。</p>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-9.jpg" alt=""></p>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>&#160; &#160; &#160; &#160;之前新生代 Parallel Scavenge很尴尬，因为只能喝serial old组，被单线程所拖累。知道Parallel Old出现，吞吐量优先收集器终于有了比较名副其实的应用组合。</p>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-11.jpg" alt=""></p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>&#160; &#160; &#160; &#160;是一种以获取最短回收停顿时间为目标的收集器。目前很多一部分的Java应用都集中在服务器上，尤其注重响应速度，希望系统停顿的时间越短越好。CMS就非常符合这个要求。</p>
<p>&#160; &#160; &#160; &#160;基于标记-清除的，但是改进了分以下四步：</p>
<ol>
<li>初识标记；仍需要暂停其他线程，仅仅是标记一下GC Roots能直接关联的对象，速度很快。</li>
<li>并发标记；进行GC Roots Tracing过程</li>
<li>重新标记；仍需要暂停其他线程，修正并发标记期间，因用户程序继续运行而导致的一部分改变，会比?????标记消耗时间长一些，比并发标记时间短。</li>
<li>并发清除；消耗时间也较长。</li>
</ol>
<p><img src="http://7xkjk9.com1.z0.glb.clouddn.com/jvm-12.jpg" alt=""></p>
<h4 id="CMS-优缺点"><a href="#CMS-优缺点" class="headerlink" title="CMS 优缺点"></a>CMS 优缺点</h4><p>&#160; &#160; &#160; &#160;CMS的优点很明显：并发收集、低停顿（由于进行垃圾收集的时间主要耗在并发标记与并发清除这两个过程，虽然初始标记和重新标记仍然需要暂停用户线程，但是从总体上看，这部分占用的时间相比其他两个步骤很小，所以可以认为是低停顿的）。</p>
<p>&#160; &#160; &#160; &#160;尽管如此，CMS收集器的缺点也是很明显的：</p>
<p>&#160; &#160; &#160; &#160;1.对CPU资源太敏感，这点可以这么理解，虽然在并发标记阶段用户线程没有暂停，但是由于收集器占用了一部分CPU资源，导致程序的响应速度变慢。（增量式并发收集器i-CMS）</p>
<p>&#160; &#160; &#160; &#160;2.CMS收集器无法处理浮动垃圾。所谓的“浮动垃圾”，就是在并发标记阶段，由于用户程序在运行，那么自然就会有新的垃圾产生，这部分垃圾被标记过后，CMS无法在当次集中处理它们（为什么？原因在于CMS是以获取最短停顿时间为目标的，自然不可能在一次垃圾处理过程中花费太多时间），只好在下一次GC的时候处理。这部分未处理的垃圾就称为“浮动垃圾”。（调高-XX：CMSInitiatingOccupancyFraction参数，太高又会造成CMF失败，后备预案就是采用Serial收集器对老年代进行，反而效率会降低）。</p>
<p>&#160; &#160; &#160; &#160;3.由于CMS收集器是基于“标记-清除”算法的，前面说过这个算法会导致大量的空间碎片的产生，一旦空间碎片过多，大对象就没办法给其分配内存,那么即使内存还有剩余空间容纳这个大对象，但是却没有连续的足够大的空间放下这个对象，所以虚拟机就会触发一次Full GC（这个后面还会提到）这个问题的解决是通过控制参数-XX:+UseCMSCompactAtFullCollection，用于在CMS垃圾收集器顶不住要进行FullGC的时候开启空间碎片的合并整理过程。相应停顿也不得不变长。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>&#160; &#160; &#160; &#160;G1时当前收集器技术中最前沿的成果。相比之前的CMS收集器又两个改进：</p>
<ol>
<li>基于标记-整理算法实现，也就是说不会产生碎片。</li>
<li>精确的控制停顿，在M毫秒哪，收集时间不超过N毫秒，这几乎已经时实时java（RTSJ）的垃圾收集器特征了。</li>
</ol>
<p>&#160; &#160; &#160; &#160;将整个Java堆划分为多个大小固定的独立区域，并且跟踪这些区域厘米的垃圾堆积程度，后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域，这就是Garbage First的由来。保证有效时间内获得更高的收集效率。</p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>&#160; &#160; &#160; &#160;Java技术体系中所提倡的自动内存管理最终归结为自动化解决了两个问题：给内存分配对象以及回收分配给对象的内存。接下来再来说说内存分配，往大方向讲，就是在堆上分配。<br>根据设置参数和收集器的使用组合不同，内存分配机制可能不同，但是我们讲述一般性规则，分析之前先看看两种GC：</p>
<ol>
<li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，比较频繁，回收速度也快。</li>
<li>老年代GC （Full GC／Major GC）：发生在老年代的GC，经常伴随着至少一次Minor GC，但不是绝对，速度较慢，。</li>
</ol>
<h3 id="对象优先在Eden中分配"><a href="#对象优先在Eden中分配" class="headerlink" title="对象优先在Eden中分配"></a>对象优先在Eden中分配</h3><p>&#160; &#160; &#160; &#160;大多数情况下，对象优先在新生代Eden区中分配。当Eden没有足够空间的时候，会发起一次Minor GC。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>&#160; &#160; &#160; &#160;需要大量连续空间的Java对象，很长的字符串及数组等，所以程序中不要写短命大对象。（不进入Eden和Survivor时因为他们采用复制算法）。</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>&#160; &#160; &#160; &#160;虚拟机给每一个对象一个年龄计数器，默认15岁。</p>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>&#160; &#160; &#160; &#160;如果Survivor空间中相同年龄所以对象总和大于空间的一半，年龄大于等于该年龄的进入老年代。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>&#160; &#160; &#160; &#160;发生 Minor GC时，虚拟机会检测晋升到老年代的空间是否够，如果不够就发起一次Full GC，如果小于，如果参数HannlePromotionFailure设置允许担保失败，就只会进行Minor GC；</p>
<h3 id="Minor-GC／Full-GC触发条件"><a href="#Minor-GC／Full-GC触发条件" class="headerlink" title="Minor GC／Full GC触发条件"></a>Minor GC／Full GC触发条件</h3><ol>
<li><p>Minor GC触发条件：当Eden区满时，触发Minor GC。</p>
</li>
<li><p>Full GC触发条件：</p>
</li>
</ol>
<p>（1）调用System.gc时，系统建议执行Full GC，但是不必然执行</p>
<p>（2）老年代空间不足</p>
<p>（3）方法区空间不足</p>
<p>（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p>
<p>（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;本次介绍了垃圾收集算法和多种收集器，以及自动内存分配的一些机制。内存回收与垃圾收集在很多时候都是影响系统性能、并发俄力的主要因素之一，虚拟机提供了多种不同收集器与大量调节参数。必须要了解每个具体收集器行为、优点缺点。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在了解了Java运行时内存区域之后，我们知道虚拟机可能造成内存溢出OOM，虽然有垃圾回收机制，但是可能也不能避免，&lt;font color=&quot;red&quot;&gt;我们现在就看看Java的垃圾收集机制为例避免内存溢出异常已经做出了哪些努力。&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java的垃圾收集机制" scheme="http://yoursite.com/tags/Java%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机（二）</title>
    <link href="http://yoursite.com/2017/01/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/04/深入理解JAVA虚拟机（二）/</id>
    <published>2017-01-04T02:10:16.000Z</published>
    <updated>2017-07-10T11:37:38.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p><strong>本章主要内容</strong></p>
<ul>
<li>对象访问</li>
</ul>
<hr>
<p>在Java中，对象访问是如何进行的？</p>
<p>　　对象访问在Java中无处不在，是最普通的程序行为，但是最简单的访问也会涉及 <strong>Java栈、Java堆、方法区</strong>这三个最重要的内存区域之间的关联关系。如：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object obj = new Object();</div></pre></td></tr></table></figure>
<p>　　其中， <code>Object obj</code>这部分的语义会反映到Java栈的本地变量表中，最为一个reference类型数据出现。而 <code>new Object()</code>这部分的语义会反映到Java堆中，形成一块存储了Object类型所有实例数据值的结构化内存，根据具体类型及虚拟机实现的对象内存布局不同，这块内存是不固定的。在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。</p>
<h2 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h2><p>主流的访问方式有两种：</p>
<ul>
<li><strong>句柄访问方式</strong>，Java堆中将会划分出一块内存来作为 <strong>句柄池</strong>，引用类型数据中存储的就是对象的句柄地址，句柄中包含了 <strong>对象实例数据</strong>和 <strong>类型数据</strong> 各自的具体地址信息。</li>
</ul>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt=""></p>
<ul>
<li><strong>直接指针访问方式</strong>，引用类型数据中存储的就是对象地址。</li>
</ul>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt=""></p>
<style>
table th:first-of-type {
    width: 100px;
}
</style>

<table>
<thead>
<tr>
<th style="text-align:left">访问方式</th>
<th>优点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">句柄访问</td>
<td>reference中存储的是稳定的句柄地址，在对象被移动中只会改变句柄中实例数据指针，而reference本身不必修改</td>
</tr>
<tr>
<td style="text-align:left">直接指针访问</td>
<td>速度快，节省了一次指针定位的时间开销</td>
</tr>
</tbody>
</table>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>　　文中出现的图片，文字描述来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象访问&quot;&gt;&lt;a href=&quot;#对象访问&quot; class=&quot;headerlink&quot; title=&quot;对象访问&quot;&gt;&lt;/a&gt;对象访问&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本章主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象访问&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;在Java中，对象访问是如何进行的？&lt;/p&gt;
&lt;p&gt;　　对象访问在Java中无处不在，是最普通的程序行为，但是最简单的访问也会涉及 &lt;strong&gt;Java栈、Java堆、方法区&lt;/strong&gt;这三个最重要的内存区域之间的关联关系。如：&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="对象访问" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>深入学习JAVA虚拟机（一）</title>
    <link href="http://yoursite.com/2017/01/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/03/深入理解JAVA虚拟机（一）/</id>
    <published>2017-01-03T12:11:32.000Z</published>
    <updated>2017-05-12T08:13:10.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java内存区域与内存溢出异常"><a href="#java内存区域与内存溢出异常" class="headerlink" title="java内存区域与内存溢出异常"></a>java内存区域与内存溢出异常</h2><hr>
<p><strong>本章主要内容</strong></p>
<ul>
<li>运行时数据区域</li>
</ul>
<hr>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把他所管理的内存划分成若干不同的数据区域。<br>  <img src="http://oppqlui3e.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt=""></p>
<p>  　　这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。<br><a id="more"></a></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h4><p>　　程序计数器(Program Counter Register) 是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，<strong>分支、循环、跳转、异常处理、线程恢复等</strong>基础功能都需要依赖这个计数器来完成。</p>
<ul>
<li>Java虚拟机的多线程通过轮流切换并分配处理器执行时间实现。</li>
<li>在任何一个确定的时刻，一个处理器只会执行一条线程的指令。</li>
<li>每个线程都有一个独立的程序计数器，线程切换后，找到正确的执行位置。</li>
<li>各线程之间的计数器独立存储。</li>
</ul>
<p>　　如果线程正在执行的是一个Java方法，这个计数器记录的时正在执行的虚拟机字节码指令的地址；如果正在执行的是<strong>Native方法</strong>，这个计数器的值为空。此内存区域是唯一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a><strong>Java虚拟机栈</strong></h4><p>　　与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同。它描述的Java方法执行的内存模型。</p>
<ul>
<li>每个方法被执行的时候会创建一个栈帧(Stack Frame)。</li>
<li>栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。</li>
<li>方法从被调用到执行完成对应着一个栈帧在虚拟机栈中入站到出站的过程。</li>
</ul>
<p>通常最关注的、与对象内存分配关系最密切的内存区就是<strong>虚拟机栈</strong>（局部变量表）和<strong>Java堆</strong>。<br><strong>局部变量表</strong>存放了编译器可知的各种基本数据类型：</p>
<ul>
<li>byte (1 Slot)</li>
<li>short(1 Slot)</li>
<li>int(1 Slot)</li>
<li>char(1 Slot)</li>
<li>float(1 Slot)</li>
<li>long(2 Slot)</li>
<li>double(2 Slot)</li>
<li>boolean(1 Slot)</li>
</ul>
<p>　　其中64位长度的long 和double类型的数据会占用2个局部变量空间(Slot),其余的只占一个。<br>　　局部变量表所需的内存空间<strong>在编译期间完成分配</strong>，进入一个方法时，这个方法需要在帧中<strong>分配多大的局部变量空间是完全确定的</strong>，在方法运行期间不会改变局部变量表的大小。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h4><p>　　与虚拟机栈的作用类似，虚拟机栈为虚拟机执行<strong>Java方法</strong>（字节码）服务，本地方法栈为虚拟机的<strong>Native方法</strong>服务。具体的虚拟机可以自由实现本地方法栈。</p>
<h4 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a><strong>Java栈</strong></h4><ul>
<li>Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。</li>
<li>Java堆被<strong>所有线程共享</strong>的一块内存区域，在虚拟机启动时创建。</li>
<li>此内存区域唯一目的就是<strong>存放对象实例</strong>。</li>
<li>Java堆是垃圾收集器管理的主要区域。</li>
<li>Java堆只要求逻辑上连续，可以处于物理上不连续的内存空间中。</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h4><ul>
<li>方法区(Method Area) 与Java堆一样，是个各线程共享的内存区域。</li>
<li>用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</li>
<li>不需要连续的内存，还可以选择不实现垃圾收集。</li>
<li>这个区域的内存回收目标主要是<strong>针对常量池的回收</strong>和对<strong>类型的卸载</strong>。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h4><ul>
<li>运行时常量池(Runtime Constant Pool)是方法区的一部分。</li>
<li>用于存放<strong>编译期</strong>生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>运行时常量池具备动态性，即运行期间也可能将新的常量放入池中，例如String类的intern()方法。</li>
<li>当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</li>
</ul>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a><strong>直接内存</strong></h4><ul>
<li>不属于虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是被频繁使用。</li>
<li>本机直接内存的分配不受到Java堆大小的限制，但是会受到本机总内存(RAM及SWAP区或分页文件)的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时一般会根据实际内存设置-Xmx等参数信息，但是经常忽略直接内存，使得各个内存区域的总和大于物理内存限制，导致动态扩展时出现OutOfMemoryError异常。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java内存区域与内存溢出异常&quot;&gt;&lt;a href=&quot;#java内存区域与内存溢出异常&quot; class=&quot;headerlink&quot; title=&quot;java内存区域与内存溢出异常&quot;&gt;&lt;/a&gt;java内存区域与内存溢出异常&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;本章主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时数据区域&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h3&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中会把他所管理的内存划分成若干不同的数据区域。&lt;br&gt;  &lt;img src=&quot;http://oppqlui3e.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  　　这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。&lt;br&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="内存区域" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记整理（二）</title>
    <link href="http://yoursite.com/2016/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/09/18/计算机网络笔记整理（二）/</id>
    <published>2016-09-18T01:42:09.000Z</published>
    <updated>2017-05-18T06:31:16.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h3><h4 id="开放系统互连参考模型（OSI-7层模型）"><a href="#开放系统互连参考模型（OSI-7层模型）" class="headerlink" title="开放系统互连参考模型（OSI 7层模型）"></a>开放系统互连参考模型（OSI 7层模型）</h4><p>OSI的七层协议体系结构的概念清楚，理论也较完整，但是复杂也不实用。</p>
<p>　　　　　　　　　　　　<img src="http://oppqlui3e.bkt.clouddn.com/OSI%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""></p>
<h4 id="TCP-IP-4层模型"><a href="#TCP-IP-4层模型" class="headerlink" title="TCP/IP 4层模型"></a>TCP/IP 4层模型</h4><p>　　　　　　　　　　<img src="http://oppqlui3e.bkt.clouddn.com/TCPIP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""></p>
<h4 id="五层协议体系结构模型"><a href="#五层协议体系结构模型" class="headerlink" title="五层协议体系结构模型"></a>五层协议体系结构模型</h4><p>实质上讲，TCP/IP只有最上面的三层，因为最下面的网络接口层没有什么具体内容，综合OSI与TCP/IP的优点，采用五层协议的体系结构。</p>
<p>　　　　　　　　　　　　　<img src="http://oppqlui3e.bkt.clouddn.com/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""></p>
<h4 id="各层的作用"><a href="#各层的作用" class="headerlink" title="各层的作用"></a>各层的作用</h4><p><strong>应用层</strong>：结构模型中的最高层。应用层直接为用户的应用进程提供服务。应用层中包含很多协议，例如支持万维网应用的HTTP协议、支持电子邮件的SMTP协议、支持文件传送的FTP协议等等。 </p>
<p><strong>运输层</strong>：负责向两个主机中进程之间的通信提供服务。由于一个主机可以运行多个进程，因此运输层有复用和分用的功能。复用指多个应用层进程可同时使用传输层的服务，分用指运输层把收到的信息分别交付给应用层中相应的进程。</p>
<p><strong>主要使用以下两种协议</strong>： </p>
<ul>
<li>传输控制协议TCP：面向连接，数据传输单位是报文段，提供可靠的交付 </li>
<li>用户数据报协议UDP：无连接，数据传输单位是用户数据报，不提供可靠交付 </li>
</ul>
<p><strong>网络层</strong>：负责为分组交换网上的不同主机提供通信服务。网络层把传输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，网际层采用IP协议，因此分组也被成为IP数据报或数据报。 </p>
<p><strong>数据链路层</strong>：将网络层交下来的IP数据报组装成帧，实现点到点的传递。每帧包括控制信息和数据。</p>
<p><strong>物理层</strong>：通过媒介透明的传送比特流。</p>
<h3 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h3><p><strong>实体</strong>：表示任何可以发送或接受信息的硬件或软件进程，例如ISO体系结构中的每一层都可以看作一个实体。</p>
<p><strong>协议</strong>：控制两个对等实体（或多个实体）进行通信的规则的集合。两个对等实体间的通信是的本层能够向上一层提供服务。要实现本层协议，需要调用下一层提供的服务。ISO把对等实体之间传送的数据单位称为该层的协议数据单元PDU。 </p>
<p><strong>服务</strong>：下层向上层通过层之间的接口提供的服务。 </p>
<p><strong>服务访问点SAP</strong>：在同一系统中相邻两层的实体进行数据交互的地方。层之间可以有多个SAP，每个SAP有唯一地址。ISO把层之间交换的数据单位成为服务数据单元SDU。</p>
<p><strong>协议和服务的区别</strong>： </p>
<ul>
<li><p>协议的实现保证能向上一层提供服务。使用本层服务的上一层实体只能看见服务而不能看见该层的协议。 </p>
</li>
<li><p>协议是”水平的“，协议是对等实体间的通信规则。服务是”垂直的“，下层实体通过层间接口向上层实体提供服务。</p>
</li>
</ul>
<p>网络协议由以下三个要素组成： </p>
<ul>
<li><p>语法：即数据与控制信息的结构或格式。 </p>
</li>
<li><p>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应。 </p>
</li>
<li><p>时序：即事件实现顺序的详细说明。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;五层协议的体系结构&quot;&gt;&lt;a href=&quot;#五层协议的体系结构&quot; class=&quot;headerlink&quot; title=&quot;五层协议的体系结构&quot;&gt;&lt;/a&gt;五层协议的体系结构&lt;/h3&gt;&lt;h4 id=&quot;开放系统互连参考模型（OSI-7层模型）&quot;&gt;&lt;a href=&quot;#开放系统互
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络体系结构" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记整理（一）</title>
    <link href="http://yoursite.com/2016/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/09/17/计算机网络笔记整理（一）/</id>
    <published>2016-09-17T01:42:09.000Z</published>
    <updated>2017-05-16T05:45:51.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h3><p>　　因特网是世界上最大的互连网络，习惯上大家把连接在因特网上的计算机都称为主机（host）。网络互连并不是把计算机简单地在物理上连接起来，还需要计算机安装能够交互信息的软件。</p>
<h4 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h4><p>　　 <strong>第一阶段是从单个网络ARPANET向互联网发展的过程</strong>。1969年美国国防部创建的第一个分组交换网ARPANET最初只是一个单个的分组交换网(并不是一个互连的网络)。所有要连接在ARPANET上的主机都直接与就近的结点交换机相连。 <strong>但到了上世纪70年代中期，人们己认识到不可能仅使用一个单独的网络来满足所有的通信问题。于是ARPA开始研究多种网络(如分组无线电网络)互连的技术，这就导致后来互连网的出现。</strong>这样的互连网就成为现在因特网((Internet)的雏形。 <strong>1983年，TCP/IP协议成为ARPANET上的标准协议</strong>，使得所有使用TCP/IP协议的计算机都能利用互连网相互通信，因而人们就把1983年作为因特网的诞生时间。1990年，ARPANET正式宣布关闭，因为它的实验任务己经完成。<br><a id="more"></a><br>　　 <strong>第二阶段的特点是建成了三级结构的因特网</strong>。从1985年起，美国国家科学基金会NSF(National Science Foundation)就围绕六个大型计算机中心建设计算机网络，即国家科学基金网NSFNET。它是一个三级计算机网络，分为 <strong>主干网、地区网和校园网(或企业网)</strong>。这种三级计算机网络覆盖了全美国主要的大学和研究所，并且成为因特网中的主要组成部分。1991年，NSF和美国的其他政府机构开始认识到， <strong>因特网必将扩大其使用范围，不应仅限于大学和研究机构</strong>。世界上的许多公司纷纷接入到因特网，网络上的通信量急剧增大，使因特网的容量己满足不了需要。于是美国政府决定将因特网的主干网转交给私人公司来经营，并开始对接入因特网的单位收费。1992年因特网上的主机超过100万台。1993年因特网主干网的速率提高到45Mb/s (T3速率)。</p>
<p>　　 <strong>第三阶段的特点是逐渐形成了多层次ISP结构的因特网</strong>。从1993年开始，由美国政府资助的NSFNET逐渐被若干个商用的 <strong>因特网主干网</strong>替代，而政府机构不再负责因特网的运营。这样就出现了一个新的名词: <strong>因特网服务提供者ISP</strong> (Internet Service Provider)。在许多情况下，因特网服务提供者ISP就是一个进行商业活动的公司，因此ISP又常译为 <strong>因特网服务提供商</strong>。例如，中国电信、中国联通和中国移动就是我国最有名的ISP。</p>
<p>　　ISP可以从因特网管理机构申请到很多IP地址(因特网上的主机都必须有IP地址才能上网，同时拥有通信线路(大的ISP自己建造通信线路，小的ISP则向电信公司租用通信线路)以及路由器等连网设备，因此任何机构和个人只要向某个ISP交纳规定的费用，就可从该ISP获取所需IP地址的使用权，并可通过该ISP接入到因特网。 <strong>所谓“上网”就是指“(通过某个ISP获得的IP地址)接入到因特网”</strong>，IP地址的管理机构不会把一个单个的IP地址分配给单个用户(不“零售”IP地址)，而是把一批IP地址有偿租赁给经审查合格的ISP(只“批发”IP地址)。由此可见，现在的因特网已不是某个单个组织所拥有而是全世界无数大大小小的ISP所共同拥有的，这就是因特网也称为“网络的网络”的原因。</p>
<p><strong>注意以下两个意思相差很大的名词Internet和Internet</strong>:</p>
<p>　　以小写字母i开始的Internet(互联网或互连网)是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议(即通信规则)可以是任意的。</p>
<p>　　以大写字母I开始的Internet(因特网)则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP/IP协议族作为通信的规则，且其前身是美国的AIZPANET。</p>
<h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><ul>
<li><strong>边缘部分</strong>由所有连接在因特网上的主机组成。由 <strong>用户直接使用</strong>，进行通信（传输数据，音频或视频）和资源共享。</li>
<li><strong>核心部分</strong>由 <strong>大量网络和连接这些网络的路由器</strong>组成。为 <strong>边缘部分提供服务</strong>（提供连通性和交换）。</li>
</ul>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%90.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<h4 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h4><p>　　 <strong>边缘部分</strong>指的是连接在因特网上的所有主机。这些主机称为端系统。小到个人电脑，大到大型计算机。边缘部分利用核心部分提供的服务，使众多主机之间能互相通信。</p>
<p>　　 <strong>主机A和主机B进行通信</strong>，实际指 运行在主机A上的 <strong>某个程序</strong>和运行在主机B上的另一个程序进行通信。即主机A的 <strong>某个进程</strong>和主机B上的另一个进程进行通信。</p>
<p>边缘系统中程序的通信方式：</p>
<ul>
<li><strong>客户端服务器方式</strong>（C/S方式）</li>
<li><strong>对等方式</strong>（P2P方式）</li>
</ul>
<h5 id="客户端服务器方式"><a href="#客户端服务器方式" class="headerlink" title="客户端服务器方式"></a>客户端服务器方式</h5><ul>
<li><strong>客户端</strong>和 <strong>服务器</strong>都是指通信中所涉及的两个应用进程。</li>
<li>客户服务器方式所描述的是进程之间服务河北服务的关系。</li>
<li>客户是服务的 <strong>请求方</strong>，服务器是服务的 <strong>提供方</strong>。</li>
</ul>
<p>客户A向服务器B发出请求服务，而服务器B向客户A提供服务，如下图：</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<h5 id="客户端服务器方式的特点"><a href="#客户端服务器方式的特点" class="headerlink" title="客户端服务器方式的特点"></a>客户端服务器方式的特点</h5><ul>
<li><strong>客户程序</strong>，被用户调用和运行，在通信时主动向远地服务器发起通信（请求服务）。因此， <strong>客户端程序必须知道服务器程序的地址</strong>。</li>
<li><strong>客户程序</strong>，不需要特殊的硬件和复杂的操作系统。</li>
<li><strong>服务器程序</strong>，可 <strong>同时处理</strong>多个原地或本地客户的请求。</li>
<li><strong>服务器程序</strong>，系统启动后自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此， <strong>不需要知道客户端程序地址</strong>。</li>
<li><strong>服务器程序</strong>，需要强大的硬件和高级的操作系统支持。</li>
</ul>
<h5 id="对等连接方式"><a href="#对等连接方式" class="headerlink" title="对等连接方式"></a>对等连接方式</h5><ul>
<li>两个主机在通信时 <strong>不区分</strong>哪一个式服务请求方还是服务提供方。</li>
<li>只要两个主机都运行了对等连接软件，他们就可以<strong>平等的、对等连接通信</strong>。</li>
<li>可以下载对方已经存储在硬盘中的共享文档。</li>
</ul>
<h5 id="对等连接方式的特点"><a href="#对等连接方式的特点" class="headerlink" title="对等连接方式的特点"></a>对等连接方式的特点</h5><p>本质上，对等连接仍是客户服务器方式，只是对等连接中的每一个主机即是客户又同时是服务器。</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/P2P%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<h4 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h4><ul>
<li>向网络边缘中的大量主机提供 <strong>连通性</strong>，是边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</li>
<li>在核心部分起特殊作用的是路由器。</li>
<li>路由器是实现 <strong>分组交换</strong>的关键构件，其任务是转发收到的分组。</li>
</ul>
<p>三种交换方式：</p>
<ul>
<li>电路交换，整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li>
<li>报文交换，整个报文先传送到相邻结点，全部存储下来后查找转发表，转发下一个结点。</li>
<li>分组交换，单个分组传送到相邻结点，存储下来后查找转发表，转发下一个结点。</li>
</ul>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F.png" alt=""></p>
<h5 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h5><p><img src="http://oppqlui3e.bkt.clouddn.com/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<p>建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）</p>
<p>其特点是，在通话全部时间内，通话的两个用户始终占用端到端的通信资源。</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E5%8D%A0%E7%94%A8%E8%B5%84%E6%BA%90.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""><br>用电路交换来传送计算机数据时， <strong>其线路传输效率往往很低</strong>。</p>
<h5 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h5><p>　　通常把要发送的整块数据称为一个 <strong>报文</strong>。在发送报文前先把较长的报文划分成一个个更小的 <strong>等长数据段</strong>。在每个数据段前加上一些必要的控制信息组成的 <strong>首部</strong>后，就构成了一个 <strong>分组</strong>，分组又称为 <strong>包</strong>。</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E5%88%92%E5%88%86%E5%88%86%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5.png" alt=""><br>分组交换的优点：</p>
<ul>
<li><strong>高效</strong>，动态分配传输带宽，对通信链路是逐段占用。</li>
<li><strong>灵活</strong>，以分组为传送单位和查找路由。</li>
<li><strong>迅速</strong>，不必先建立连接就能向其他主机发送分组。</li>
<li><strong>可靠</strong>，保证可靠性的网络协议，分布式的路由选择协议使网络有很好的生存性。</li>
</ul>
<p>分组交换存在的问题：</p>
<ul>
<li>分组在各个节点存储转发时需要排队，这会造成一定的时延。</li>
<li>分组必须携带首部，造成了一定的开销。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;因特网概述&quot;&gt;&lt;a href=&quot;#因特网概述&quot; class=&quot;headerlink&quot; title=&quot;因特网概述&quot;&gt;&lt;/a&gt;因特网概述&lt;/h3&gt;&lt;p&gt;　　因特网是世界上最大的互连网络，习惯上大家把连接在因特网上的计算机都称为主机（host）。网络互连并不是把计算机简单地在物理上连接起来，还需要计算机安装能够交互信息的软件。&lt;/p&gt;
&lt;h4 id=&quot;因特网发展的三个阶段&quot;&gt;&lt;a href=&quot;#因特网发展的三个阶段&quot; class=&quot;headerlink&quot; title=&quot;因特网发展的三个阶段&quot;&gt;&lt;/a&gt;因特网发展的三个阶段&lt;/h4&gt;&lt;p&gt;　　 &lt;strong&gt;第一阶段是从单个网络ARPANET向互联网发展的过程&lt;/strong&gt;。1969年美国国防部创建的第一个分组交换网ARPANET最初只是一个单个的分组交换网(并不是一个互连的网络)。所有要连接在ARPANET上的主机都直接与就近的结点交换机相连。 &lt;strong&gt;但到了上世纪70年代中期，人们己认识到不可能仅使用一个单独的网络来满足所有的通信问题。于是ARPA开始研究多种网络(如分组无线电网络)互连的技术，这就导致后来互连网的出现。&lt;/strong&gt;这样的互连网就成为现在因特网((Internet)的雏形。 &lt;strong&gt;1983年，TCP/IP协议成为ARPANET上的标准协议&lt;/strong&gt;，使得所有使用TCP/IP协议的计算机都能利用互连网相互通信，因而人们就把1983年作为因特网的诞生时间。1990年，ARPANET正式宣布关闭，因为它的实验任务己经完成。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络概述" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java基础原理笔记（二）</title>
    <link href="http://yoursite.com/2016/09/11/Java%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/09/11/Java基础原理笔记（二）/</id>
    <published>2016-09-11T08:20:57.000Z</published>
    <updated>2017-05-16T01:57:55.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型和运算符"><a href="#数据类型和运算符" class="headerlink" title="数据类型和运算符"></a>数据类型和运算符</h3><p><strong>本章主要内容</strong></p>
<ul>
<li>基本类型的转换</li>
<li>直接量</li>
<li>运算符</li>
</ul>
<h3 id="基本类型的类型转换"><a href="#基本类型的类型转换" class="headerlink" title="基本类型的类型转换"></a>基本类型的类型转换</h3><hr>
<p>Java语言所提供的7中数值类型之间可以相互转换，有两种转换方式： <strong>自动类型转换、强制类型转换</strong></p>
<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><hr>
<p>　　当把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，西东可以自动类型转换，反之，则需要强制转换。</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt=""><br><a id="more"></a><br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int a = 6;</div><div class="line">float b = a;//此时b的值为6.0</div><div class="line"></div><div class="line">byte c = 7;</div><div class="line">//下面代码将出错，byte类型不能自动转换成char类型</div><div class="line">char d = b;</div></pre></td></tr></table></figure>
<p>　　特别地，当任何基本类型的值和字符串值进行连接运算时，基本类型的值会自动转换成字符串类型的值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String TransToStr = 2.5f + &quot;&quot;;</div><div class="line"></div><div class="line">String Str1 = 3 + 4 + &quot;Hello!&quot;;//Str1的值为 &quot;7Hello!&quot;</div><div class="line"></div><div class="line">String Str2 = &quot;Hello!&quot; + 3 + 4;//Str2的值为 &quot;Hello34&quot;</div></pre></td></tr></table></figure>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><hr>
<p>　　强制类型转换的格式为(targetType)value，需要注意的是，若转换的值超过了目标类型的表数范围，将会引起溢出，造成数据丢失，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int iValue = 233;</div><div class="line">//将int型强制转换成byte型</div><div class="line">byte bValue = (byte)iValue;</div><div class="line">//数据溢出，将输出-23</div><div class="line">System.out.println(bValue);</div><div class="line"></div><div class="line">double dValue = 3.98;</div><div class="line">//将double型强制转换成int型</div><div class="line">int tol = (int)dValue;</div><div class="line">//将输出3</div><div class="line">System.out.println(tol);</div></pre></td></tr></table></figure>
<p>原理：<br><img src="http://oppqlui3e.bkt.clouddn.com/int%E8%BD%ACbyte.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<p>　　32位int类型的233强制转换为8位的byte类型，需要截断前面的24位，截断后最左一位表示符号位，而负数在计算机中以补码形式存在，则11101001转成原码还需减一取反，得到10010111，即为-23。</p>
<p>另外，有一个容易出错的地方，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//5.6默认是double型的，直接赋给一个float型的变量会出错</div><div class="line">float a = 5.6;</div><div class="line">//应为</div><div class="line">float a = (float)5.6;</div></pre></td></tr></table></figure>
<p>　　一般的，字符串不能直接转换为基本类型，但是可以通过基本类型对应的包装类实现字符串转基本类型，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String a = &quot;25&quot;;</div><div class="line">int iValue = Integer.parseInt(a);</div></pre></td></tr></table></figure>
<p>Java中八种基本类型对应的包装类如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">基本类型</th>
<th style="text-align:center">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:center">Boolean</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:center">Integer</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:center">charcter</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:center">Double</td>
</tr>
</tbody>
</table>
<p>8个包装类均提供parseXxx(String str)静态方法用于将字符串转成对应的基本类型。</p>
<h3 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h3><hr>
<p>能指定直接量的通常只有三种类型： <strong>基本类型、字符类型、null型</strong></p>
<ul>
<li>基本类型： <strong>int、long、float、double、Boolean、char</strong></li>
<li>字符类型： <strong>String</strong></li>
<li>null类型： 只有一个值,即为 <strong>null</strong></li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>String类型的直接量不能赋给其他类型的变量</li>
<li>null类型的直接量可以直接赋给任何引用类型的变量</li>
<li>Boolean类型的直接量只能赋给Boolean类型的变量</li>
</ul>
<p>　　 <strong>关于字符串直接量有一点需要指出</strong>，当程序第一次使用某个字符串直接量时，Java会使用常量池来缓存该字符串直接量，若后续要使用该字符串直接量，Java会直接使用常量池中的该直接量。</p>
<p>　　 <strong>常量池</strong>指的是在编译期被确定，并被保存在已编译的.class魏建忠的一些数据。它包括关于 <strong>类、方法、接口</strong>中的常量，也包括 <strong>字符串常量</strong>。</p>
<p>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String s0 = &quot;hello&quot;;</div><div class="line">String s1 = &quot;hello&quot;;</div><div class="line">String s2 = &quot;he&quot; + &quot;llo&quot;;</div><div class="line">System.out.println( s0 == s1);</div><div class="line">System.out.println( s0 == s2);</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div></pre></td></tr></table></figure>
<p>　　因为Java会确保每个字符串常量只有一个，不会产生多个副本。例子中的s0和s1中的”hello”都是字符串常量，他们在编译期就被确定了，所以s0==s1返回true;s2同样在编译器就被解析为一个字符串常量，所以s2也是常量池中”hello”的引用。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><hr>
<p>Java中的算术运算符可分为如下几种：</p>
<ul>
<li><strong>算术运算符</strong></li>
<li><strong>赋值运算符</strong></li>
<li><strong>比较运算符</strong></li>
<li><strong>逻辑运算符</strong></li>
<li><strong>位运算符</strong></li>
<li><strong>类型相关运算符</strong></li>
</ul>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><hr>
<ul>
<li>+：加法运算符</li>
<li>-：减法运算符</li>
<li>*：乘法运算符</li>
<li>/：除法运算符</li>
<li>%：求余运算符</li>
<li>++：自加</li>
<li>–：自减</li>
</ul>
<p><strong>注意</strong>：自加和自减只能用于 <strong>操作变量</strong>，不能用于操作数值直接量、常量或表达式。如：5++、6–都是错误的。</p>
<p>Java没有提供更复杂的运算符，如果要完成乘方、开方等运算，需借助 <strong>java.lang.Math</strong>类的工具方法完成。</p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><hr>
<p>用于为变量指定变量值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;Java&quot;;</div><div class="line"></div><div class="line">String str2 = str;</div></pre></td></tr></table></figure>
<p><strong>把变量当成一个盛装数据的容器，赋值运算就相当于“装入”的过程</strong>。赋值运算符是 <strong>从右向左</strong>执行计算的，程序先计算得到 <code>=</code>右边的值，再把该值装入左边的变量中。因此， <code>=</code>左边只能是变量。</p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><hr>
<ul>
<li>&amp;：按位与。当两位同时为1时才返回1。</li>
<li>|：按位或。只要有一位为1即可返回1。</li>
<li>~：按位非。单目运算符，将操作数的每个位（包括符号位）全部取反。</li>
<li>^ ：按位异或。当两位相同时返回0，不同时返回1。</li>
<li>&lt;&lt;：左移运算符。</li>
<li>＞＞：右移运算符。</li>
<li>＞＞＞：无符号右移运算符。</li>
</ul>
<p>实例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(5 &amp; 9);//输出1</div><div class="line">System.out.println(5 | 9);//输出13</div></pre></td></tr></table></figure>
<p>原理如下：</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E4%B8%8E%E6%88%96%E8%BF%90%E7%AE%97.png" alt=""></p>
<p>按位异或和按位取反：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(~-5);//输出4</div><div class="line">System.out.println(5 ^ 9);//输出12</div></pre></td></tr></table></figure>
<p>按位取反原理如下：<br><img src="http://oppqlui3e.bkt.clouddn.com/%E9%9D%9E%E8%B4%9F5.png" alt=""></p>
<p>按位异或原理如下：<br><img src="http://oppqlui3e.bkt.clouddn.com/59%E5%BC%82%E6%88%96.png" alt=""></p>
<p>左移运算符是将操作数的二进制码整体左移指定位数，左移后右边空出来的用0补充，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(5 &lt;&lt; 2);//输出20</div><div class="line">System.out.println(-5 &lt;&lt; 2);//输出-20</div></pre></td></tr></table></figure>
<p>左移原理如下：<br><img src="http://oppqlui3e.bkt.clouddn.com/%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97.png" alt=""></p>
<p>　　Java的右移运算符有两个 <strong>&gt;&gt;、&gt;&gt;&gt;</strong>，对于 <code>&gt;&gt;</code>运算符而言，把第一个操作数的二进制码右移指定位数后，左边空出来的为以原来的符号位填充，即如果是一个整数则以0补充，如果第一个操作数是负数则补1。 <code>&gt;&gt;&gt;</code>把第一个操作数右移指定位数后总以0补充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(5 &gt;&gt; 2);//输出-2</div><div class="line">System.out.println(-5 &gt;&gt;&gt; 2);//输出1073741822</div></pre></td></tr></table></figure>
<p><strong>-5&gt;&gt;2的运算原理</strong>：<br><img src="http://oppqlui3e.bkt.clouddn.com/-5%E5%8F%B3%E7%A7%BB2%E4%BD%8D.png" alt=""></p>
<p><strong>-5&gt;&gt;&gt;2的运算原理</strong>:</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/-5%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB.png" alt=""></p>
<p>注意： <strong>进行移位运算不会改变操作数本身，只是得到一个新的运算结果，原来的操作数本身不会改变</strong>。</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><hr>
<p>比较运算符用于判断两个变量或常量的大小，其结果是一个布尔值（true或false），如下：</p>
<ul>
<li>＞：大于，（只支持数值类型）</li>
<li>＞=：大于等于，（只支持数值类型）</li>
<li>&lt;：小于，（只支持数值类型）</li>
<li>&lt;=：小于等于，（只支持数值类型）</li>
<li>==：等于， 如果两边都是数值类型，即使它们数据类型不同，只要值相等也会返回true。如果两边是引用类型， <strong>只有当两个引用变量具有父子关系时才可比较</strong>，同时，这两个变量必须指向 <strong>同一个对象</strong>才会返回true。</li>
<li>!=：不等于，（同==）</li>
</ul>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><hr>
<p>用于操作两个布尔类型的变量或常量，如下：</p>
<ul>
<li>&amp;&amp;：与，两边为true时返回true</li>
<li>&amp;： 不短路与，（同&amp;&amp;）但不会短路</li>
<li>||：或，两边有一个为true返回true</li>
<li>|： 不短路或</li>
<li>!： 非，只有一个操作数，为true返回false</li>
<li>^ ：异或，两边结果不同时返回true，相同返回false</li>
</ul>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><hr>
<p>三目运算符只有一个：（？：）</p>
<p>格式为：(expression) ? if-true-statement : if-false-statment;</p>
<h4 id="运算符结合性和优先级"><a href="#运算符结合性和优先级" class="headerlink" title="运算符结合性和优先级"></a>运算符结合性和优先级</h4><hr>
<p><strong>单目运算符、赋值运算符、三目运算符</strong>是 <strong>从右向左</strong>运算的。</p>
<p>下表为运算符优先级表，上一行优先于下一行。</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据类型和运算符&quot;&gt;&lt;a href=&quot;#数据类型和运算符&quot; class=&quot;headerlink&quot; title=&quot;数据类型和运算符&quot;&gt;&lt;/a&gt;数据类型和运算符&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;本章主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本类型的转换&lt;/li&gt;
&lt;li&gt;直接量&lt;/li&gt;
&lt;li&gt;运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基本类型的类型转换&quot;&gt;&lt;a href=&quot;#基本类型的类型转换&quot; class=&quot;headerlink&quot; title=&quot;基本类型的类型转换&quot;&gt;&lt;/a&gt;基本类型的类型转换&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;Java语言所提供的7中数值类型之间可以相互转换，有两种转换方式： &lt;strong&gt;自动类型转换、强制类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;自动类型转换&quot;&gt;&lt;a href=&quot;#自动类型转换&quot; class=&quot;headerlink&quot; title=&quot;自动类型转换&quot;&gt;&lt;/a&gt;自动类型转换&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;　　当把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，西东可以自动类型转换，反之，则需要强制转换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oppqlui3e.bkt.clouddn.com/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据类型转换" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Java基础原理笔记(一)</title>
    <link href="http://yoursite.com/2016/09/10/Java%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/09/10/Java基础原理笔记（一）/</id>
    <published>2016-09-10T07:06:55.000Z</published>
    <updated>2017-05-11T08:32:55.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java数据类型介绍"><a href="#Java数据类型介绍" class="headerlink" title="Java数据类型介绍"></a>Java数据类型介绍</h2><p><strong>本章主要内容</strong></p>
<ul>
<li>数据类型分类</li>
<li>基本数据类型</li>
</ul>
<hr>
<h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><p>Java语言是强类型（strongly typed）语言，强类型包含两方面的含义：</p>
<ul>
<li>所有的变量必须先声明、后使用。</li>
<li>指定类型的变量只能接受类型与之匹配的值。</li>
</ul>
<p>在了解数据类型前先弄懂两个问题：</p>
<h4 id="什么是变量？变量有什么用？"><a href="#什么是变量？变量有什么用？" class="headerlink" title="什么是变量？变量有什么用？"></a>什么是变量？变量有什么用？</h4><p>　　 <strong>编程的本质，就是对内存中的数据的访问和修改</strong>。程序所用的数据都会保存在内存中，程序员需要一种机制来访问或修改内存中的数据。这种机制就是 <strong>变量</strong>。每个变量都代表某一小块内存，而且变量是有名字的，程序对变量赋值， <strong>实际上就是把数据装入该变量所代表的内存区的过程</strong>；<br>程序读取变量的值， <strong>实际上就是从该变量所代表的内存区中取值的过程</strong>。 <strong>变量相当于一个有名称的容器，该容器用于装各种不同类型的数据</strong>。<br><a id="more"></a></p>
<p>Java语言支持的类型分为两种： <strong>基本类型</strong>和 <strong>引用类型</strong>。</p>
<p><strong>基本类型</strong>包括Boolean类型和数值类型。数值类型有整数类型和浮点类型。</p>
<p>整数类型包括： <strong>byte</strong>、 <strong>short</strong>、 <strong>int</strong>、 <strong>long</strong>、 <strong>char</strong></p>
<p>浮点类型包括： <strong>float</strong>和 <strong>double</strong></p>
<p>注意：char代表字符型，实际上字符型也是一种 <strong>整数类型</strong>，相当于 <strong>无符号整数类型</strong>。</p>
<p><strong>引用类型</strong>包括 <strong>类、接口、数组类型</strong>，还有一种特殊的 <strong>null类型</strong>。</p>
<p>引用类型就是对一个对象的引用，对象包括实例和数组两种。实际上，引用类型变量就是一个指针。</p>
<h3 id="数据基本类型"><a href="#数据基本类型" class="headerlink" title="数据基本类型"></a>数据基本类型</h3><p><img src="http://oppqlui3e.bkt.clouddn.com/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png?imageView2/2/00/h/200/q/75|imageslim" alt=""></p>
<p>Java中只包含这八种基本类型， <strong>字符串不是基本数据类型</strong>，字符串是一个类，即为一个引用数据类型。</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>int 是最常用的整数类型，因此直接给出一个整数值默认就是int类型。</p>
<p>如果直接将一个较小的整数值（在byte或short类型的表数范围内）赋给一个byte或short变量系统会自动把这个整数值当成byte/short类型来处理。但是使用一个很大的整数，Java不会把它当成long类型处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//系统不会把99999999999999999当成long类型处理,超出了int范围，引起错误</div><div class="line">long bg=99999999999999999;</div><div class="line">//应该在巨大整数值后使用L后缀，强制使用long类型</div><div class="line">long bg=99999999999999999L;</div></pre></td></tr></table></figure>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>字符型值有三种表现形式</p>
<ul>
<li>通过单个字符指定字符型值，如’A’, ‘1’。</li>
<li>通过转义字符表示特殊字符型值，如’\n’、 ‘\t’。</li>
<li>直接用Unicode值来表示字符型值’\uXXXX’， 其中XXXX代表一个十六进制的整数。<br><img src="http://oppqlui3e.bkt.clouddn.com/%E5%B8%B8%E7%94%A8%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></li>
</ul>
<p><strong>什么是字符集？</strong></p>
<p>　　给所有字符的编号组成综合。早期只要一个字节（8位）即可支持256个字符编号，就是ASCII字符集。后来又为所有的书面语言字符进行统一编号，使用2个字节（16位）支持65536个字符，这就是Unicode字符集。</p>
<p>由于计算机底层保存字符时， <strong>实际保存该字符对应的编号</strong>，因此char类型的值可直接作为整形值来使用，它相当于一个16位无符号整数，范围是0~65535。可以参与数学运算。</p>
<p><strong>用法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CharTest</div><div class="line">&#123;</div><div class="line">	public static void main(String[] args)</div><div class="line">	&#123;</div><div class="line">		char xiang= &apos;\u9999&apos;;</div><div class="line">		//将输出&apos;香&apos;字</div><div class="line">		 System.out.println(xiang);</div><div class="line">		//直接把一个0~65535内的int整数赋给一个char变量</div><div class="line">		char a = 12;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>浮点型有两种： <strong>float、double</strong></p>
<p>它们有固定的表数范围和字段长度，字段长度和表数范围与机器无关，遵循IEEE754标准。采用 <strong>二进制</strong>数据的 <strong>科学计数法</strong>来表示浮点数。</p>
<p><strong>float型</strong></p>
<p>单精度浮点数，占4字节、32位</p>
<p>第1位是符号位，接下来8为表示指数，在接下来23为表示尾数</p>
<p><strong>double型</strong></p>
<p>双精度浮点数，占8字节、64位</p>
<p>第1位是符号位，接下来11为表示指数，在接下来52为表示尾数</p>
<p><strong>十进制形式</strong>：5.22、52.0 （必须包含一个小数点，否则会被当成int类型处理）</p>
<p><strong>科学计数法</strong>： 5.2e2 或 5.2E2 (即5.2*10^2)</p>
<p>Java中浮点类型默认为double型，如果希望把一个浮点类型值当做float型来处理应在这个浮点类型值后紧跟f或F。</p>
<p>Java中有三个特殊的浮点数值： <strong>正无穷大(POSITIVE_INFINITY)、负无穷大(NEGATIVE_INFINITY)、非数(NaN)</strong>。</p>
<p>正无穷大和正无穷大相等、负无穷大和负无穷大相等、NaN和谁都不相等（包括和NaN）。 <strong>只有浮点数</strong>除0才可以得到正负无穷大，因为Java会自动把浮点数运算的0当成0.0来处理，如果一个整数除以0，则会抛出异常：ArithmeticException：/by zero</p>
<h4 id="数值中使用下划线"><a href="#数值中使用下划线" class="headerlink" title="数值中使用下划线"></a>数值中使用下划线</h4><p>可以在任意数值中自由的使用下划线，通过下划线可以更直观的分辨数值中包含多少位。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int binVal = 0B1000_0000_0000_0000_0000_0000_0011;</div><div class="line">double pi = 3.14_15_926_53_59;</div></pre></td></tr></table></figure>
<h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>布尔型只有一个Boolean类型，用于表示逻辑上的“真”或“假”。值只能是 <strong>TRUE</strong>或 <strong>FALSE</strong>。其他的基本数据类型也不能转化成Boolean类型。</p>
<p>布尔类型主要用于流程控制</p>
<ul>
<li>if条件控制语句</li>
<li>while循环控制语句</li>
<li>do循环控制语句</li>
<li>for循环控制语句</li>
</ul>
<p>布尔类型的变量还可用在三目运算符（？：）中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java数据类型介绍&quot;&gt;&lt;a href=&quot;#Java数据类型介绍&quot; class=&quot;headerlink&quot; title=&quot;Java数据类型介绍&quot;&gt;&lt;/a&gt;Java数据类型介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本章主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据类型分类&lt;/li&gt;
&lt;li&gt;基本数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;数据类型分类&quot;&gt;&lt;a href=&quot;#数据类型分类&quot; class=&quot;headerlink&quot; title=&quot;数据类型分类&quot;&gt;&lt;/a&gt;数据类型分类&lt;/h3&gt;&lt;p&gt;Java语言是强类型（strongly typed）语言，强类型包含两方面的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的变量必须先声明、后使用。&lt;/li&gt;
&lt;li&gt;指定类型的变量只能接受类型与之匹配的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在了解数据类型前先弄懂两个问题：&lt;/p&gt;
&lt;h4 id=&quot;什么是变量？变量有什么用？&quot;&gt;&lt;a href=&quot;#什么是变量？变量有什么用？&quot; class=&quot;headerlink&quot; title=&quot;什么是变量？变量有什么用？&quot;&gt;&lt;/a&gt;什么是变量？变量有什么用？&lt;/h4&gt;&lt;p&gt;　　 &lt;strong&gt;编程的本质，就是对内存中的数据的访问和修改&lt;/strong&gt;。程序所用的数据都会保存在内存中，程序员需要一种机制来访问或修改内存中的数据。这种机制就是 &lt;strong&gt;变量&lt;/strong&gt;。每个变量都代表某一小块内存，而且变量是有名字的，程序对变量赋值， &lt;strong&gt;实际上就是把数据装入该变量所代表的内存区的过程&lt;/strong&gt;；&lt;br&gt;程序读取变量的值， &lt;strong&gt;实际上就是从该变量所代表的内存区中取值的过程&lt;/strong&gt;。 &lt;strong&gt;变量相当于一个有名称的容器，该容器用于装各种不同类型的数据&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
