<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐盛的博客</title>
  <subtitle>起今知行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-04T02:23:58.173Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>徐盛</name>
    <email>544915551@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis学习笔记（二）</title>
    <link href="http://yoursite.com/2017/05/10/Redis%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/05/10/Redis笔记（二）/</id>
    <published>2017-05-10T12:05:11.000Z</published>
    <updated>2017-08-04T02:23:58.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上节总结了Redis的基本操作、特性和原理，我们还需要从使用技巧，优化策略等方面来学习。</p>
 <a id="more"></a>
<h2 id="redis和关系型数据库适用场景"><a href="#redis和关系型数据库适用场景" class="headerlink" title="redis和关系型数据库适用场景"></a>redis和关系型数据库适用场景</h2><ol>
<li><a href="http://www.jb51.net/article/62646.htm" target="_blank" rel="external">Redis数据库的使用场景介绍</a></li>
<li><a href="http://blog.csdn.net/a2534725767/article/details/54017956" target="_blank" rel="external">对比使用实例说明</a></li>
</ol>
<h2 id="key设计原则"><a href="#key设计原则" class="headerlink" title="key设计原则"></a>key设计原则</h2><p>参考实例：<a href="http://blog.csdn.net/zdp072/article/details/50986702" target="_blank" rel="external">redis key设计技巧</a>，<a href="http://www.oschina.net/question/12_27517" target="_blank" rel="external">浅谈 Redis 数据库的键值设计</a></p>
<p>总结如下：</p>
<ol>
<li>表达从属关系（一对多，多对多），最好用集合； 比如： 书名和标签，关注与被关注（微博粉丝关系）等等。</li>
<li>求最近的，一般利用链表后入后出的特性。比如：最近N个登录的用户，可以维护一个登录的链表，控制他的长度，使得里面永远保存的是最近的N个登录用户。</li>
<li>对于排序，积分榜这类需求，可以用有序集合，比如：我们把用户和登录次数统一存储在一个sorted set里，然后就可以求出登录次数最多用户。</li>
<li>对于大数据量的非是即否关系，还可以通过位图（setbit）的方式，比如：1亿个用户, 每个用户 登陆/做任意操作,记为今天活跃,否则记为不活跃；（每天一个位图来记录，会员id就是位图的位置）；</li>
</ol>
<h2 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h2><ol>
<li><a href="http://blog.sina.com.cn/s/blog_4be888450100z2ze.html" target="_blank" rel="external">Redis优化经验</a></li>
<li><a href="http://www.4wei.cn/archives/1002605" target="_blank" rel="external">Redis 优化要点</a></li>
</ol>
<p>总结：</p>
<ol>
<li>根据业务需要选择合适的数据类型，并为不同的应用场景设置相应的紧凑存储参数。</li>
<li>当业务场景不需要数据持久化时，关闭所有的持久化方式可以获得最佳的性能以及最大的内存使用量。</li>
<li>如果需要使用持久化，根据是否可以容忍重启丢失部分数据在快照方式与语句追加方式之间选择其一，不要使用虚拟内存以及diskstore方式。</li>
<li>不要让你的Redis所在机器物理内存使用超过实际内存总量的3/5。</li>
</ol>
<p>&#160; &#160; &#160; &#160;redis.conf中的maxmemory选项，该选项是告诉Redis当使用了多少物理内存后就开始拒绝后续的写入请求，该参数能很好的保护好你的Redis不会因为使用了过多的物理内存而导致swap,最终严重影响性能甚至崩溃。<br>redis.conf文件中 vm-enabled 为 no</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上节总结了Redis的基本操作、特性和原理，我们还需要从使用技巧，优化策略等方面来学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="NoSql" scheme="http://yoursite.com/tags/NoSql/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习笔记（一）</title>
    <link href="http://yoursite.com/2017/05/08/Redis%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/05/08/Redis笔记（一）/</id>
    <published>2017-05-08T01:00:20.000Z</published>
    <updated>2017-08-03T05:31:56.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;Redis作为一种典型的NoSql，可以做缓存也可以持久化，我们要从事务，消息订阅，持久化机制，集群部署，客户端使用等方面进行学习。</p>
 <a id="more"></a>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>&#160; &#160; &#160; &#160;安装部署可以根据自己的系统去找安装教程，这个不多说。Redis官方介绍说是一种开源的，BSD许可的，高级的key-value,单线程存储系统，可以用来存储字符串，哈希，链表，集合，索所以常用来提供数据结构。</p>
<p>&#160; &#160; &#160; &#160;相比另一个缓存数据看memcached，他的特点如下：</p>
<ol>
<li>Redis有持久化机制，除了缓存还可以做存储。</li>
<li>Redis数据结构丰富，而memcached只有字符串。</li>
</ol>
<p>&#160; &#160; &#160; &#160;安装成功后，有五个文件夹，分别是redis性能测试工具，aof日志工具，rdb日志工具，连接客户端和redis服务进程。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>&#160; &#160; &#160; &#160;相关指令有get，set，move，select，ttl等等，支持模糊匹配，还有一些配置设置，不同数据结构不一样，可以查API，Redis对Java，C#，C++，PHP等语言的支持，其实也就是这些操作的语言的工具包。</p>
<h2 id="数据结构底层原理"><a href="#数据结构底层原理" class="headerlink" title="数据结构底层原理"></a>数据结构底层原理</h2><ol>
<li><a href="http://blog.csdn.net/caishenfans/article/details/44784131" target="_blank" rel="external">Redis的五种对象类型及其底层实现</a>. </li>
<li><a href="http://blog.csdn.net/hanhuili/article/details/17710781" target="_blank" rel="external">深入理解Redis：底层数据结构</a></li>
</ol>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><a href="http://www.jb51.net/article/54774.htm" target="_blank" rel="external">Redis中5种数据结构的使用场景介绍</a></li>
<li><a href="http://blog.csdn.net/u011204847/article/details/51302109" target="_blank" rel="external">Redis高级特性及应用场景</a></li>
</ol>
<h2 id="事务和锁"><a href="#事务和锁" class="headerlink" title="事务和锁"></a>事务和锁</h2><ol>
<li><a href="http://blog.csdn.net/hechurui/article/details/49508749" target="_blank" rel="external">Redis事务介绍</a></li>
<li><a href="http://blog.csdn.net/bugall/article/details/52386698" target="_blank" rel="external">redis 事务实现原理</a></li>
</ol>
<h2 id="消息发布和订阅"><a href="#消息发布和订阅" class="headerlink" title="消息发布和订阅"></a>消息发布和订阅</h2><ol>
<li><a href="http://blog.csdn.net/clh604/article/details/19754939" target="_blank" rel="external">Redis 发布/订阅机制原理分析</a></li>
<li><a href="http://www.cnblogs.com/redcreen/archive/2011/02/15/1955521.html" target="_blank" rel="external">redis 发布订阅</a></li>
</ol>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>&#160; &#160; &#160; &#160;持久化有两种，快照rdb和日志aof。</p>
<ol>
<li><a href="http://blog.csdn.net/yinxiangbing/article/details/48627997" target="_blank" rel="external">redis 的两种持久化方式及原理</a></li>
<li><a href="http://www.cnblogs.com/Fairy-02-11/p/6182478.html" target="_blank" rel="external">redis持久化方法对比分析</a></li>
<li><a href="http://blog.csdn.net/freebird_lb/article/details/7778981" target="_blank" rel="external">Redis持久化</a></li>
</ol>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><ol>
<li><a href="https://my.oschina.net/pwd/blog/381212" target="_blank" rel="external">redis集群,主从复制</a></li>
</ol>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;Redis作为一种典型的NoSql，可以做缓存也可以持久化，我们要从事务，消息订阅，持久化机制，集群部署，客户端使用等方面进行学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="NoSql" scheme="http://yoursite.com/tags/NoSql/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读（三）</title>
    <link href="http://yoursite.com/2017/04/05/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/05/JDK源码阅读（三）/</id>
    <published>2017-04-05T08:23:16.000Z</published>
    <updated>2017-07-19T08:03:31.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在学习map类之后，我们今天了解list接口相关的一些类。本文转自系列博文：<a href="http://blog.csdn.net/column/details/collection.html?page=1" target="_blank" rel="external">Java集合类剖析</a>。</p>
 <a id="more"></a>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>&#160; &#160; &#160; &#160; ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。</p>
<p>&#160; &#160; &#160; &#160;ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。</p>
<p>&#160; &#160; &#160; &#160;ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">package java.util;    </div><div class="line">   </div><div class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;    </div><div class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable    </div><div class="line">&#123;    </div><div class="line">    // 序列版本号    </div><div class="line">    private static final long serialVersionUID = 8683452581122892189L;    </div><div class="line">   </div><div class="line">    // ArrayList基于该数组实现，用该数组保存数据   </div><div class="line">    private transient Object[] elementData;    </div><div class="line">   </div><div class="line">    // ArrayList中实际数据的数量    </div><div class="line">    private int size;    </div><div class="line">   </div><div class="line">    // ArrayList带容量大小的构造函数。    </div><div class="line">    public ArrayList(int initialCapacity) &#123;    </div><div class="line">        super();    </div><div class="line">        if (initialCapacity &lt; 0)    </div><div class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+    </div><div class="line">                                               initialCapacity);    </div><div class="line">        // 新建一个数组    </div><div class="line">        this.elementData = new Object[initialCapacity];    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // ArrayList无参构造函数。默认容量是10。    </div><div class="line">    public ArrayList() &#123;    </div><div class="line">        this(10);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 创建一个包含collection的ArrayList    </div><div class="line">    public ArrayList(Collection&lt;? extends E&gt; c) &#123;    </div><div class="line">        elementData = c.toArray();    </div><div class="line">        size = elementData.length;    </div><div class="line">        if (elementData.getClass() != Object[].class)    </div><div class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // 将当前容量值设为实际元素个数    </div><div class="line">    public void trimToSize() &#123;    </div><div class="line">        modCount++;    </div><div class="line">        int oldCapacity = elementData.length;    </div><div class="line">        if (size &lt; oldCapacity) &#123;    </div><div class="line">            elementData = Arrays.copyOf(elementData, size);    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // 确定ArrarList的容量。    </div><div class="line">    // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1”    </div><div class="line">    public void ensureCapacity(int minCapacity) &#123;    </div><div class="line">        // 将“修改统计数”+1，该变量主要是用来实现fail-fast机制的    </div><div class="line">        modCount++;    </div><div class="line">        int oldCapacity = elementData.length;    </div><div class="line">        // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”    </div><div class="line">        if (minCapacity &gt; oldCapacity) &#123;    </div><div class="line">            Object oldData[] = elementData;    </div><div class="line">            int newCapacity = (oldCapacity * 3)/2 + 1;    </div><div class="line">            //如果还不够，则直接将minCapacity设置为当前容量  </div><div class="line">            if (newCapacity &lt; minCapacity)    </div><div class="line">                newCapacity = minCapacity;    </div><div class="line">            elementData = Arrays.copyOf(elementData, newCapacity);    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 添加元素e    </div><div class="line">    public boolean add(E e) &#123;    </div><div class="line">        // 确定ArrayList的容量大小    </div><div class="line">        ensureCapacity(size + 1);  // Increments modCount!!    </div><div class="line">        // 添加e到ArrayList中    </div><div class="line">        elementData[size++] = e;    </div><div class="line">        return true;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回ArrayList的实际大小    </div><div class="line">    public int size() &#123;    </div><div class="line">        return size;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // ArrayList是否包含Object(o)    </div><div class="line">    public boolean contains(Object o) &#123;    </div><div class="line">        return indexOf(o) &gt;= 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    //返回ArrayList是否为空    </div><div class="line">    public boolean isEmpty() &#123;    </div><div class="line">        return size == 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 正向查找，返回元素的索引值    </div><div class="line">    public int indexOf(Object o) &#123;    </div><div class="line">        if (o == null) &#123;    </div><div class="line">            for (int i = 0; i &lt; size; i++)    </div><div class="line">            if (elementData[i]==null)    </div><div class="line">                return i;    </div><div class="line">            &#125; else &#123;    </div><div class="line">                for (int i = 0; i &lt; size; i++)    </div><div class="line">                if (o.equals(elementData[i]))    </div><div class="line">                    return i;    </div><div class="line">            &#125;    </div><div class="line">            return -1;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 反向查找，返回元素的索引值    </div><div class="line">        public int lastIndexOf(Object o) &#123;    </div><div class="line">        if (o == null) &#123;    </div><div class="line">            for (int i = size-1; i &gt;= 0; i--)    </div><div class="line">            if (elementData[i]==null)    </div><div class="line">                return i;    </div><div class="line">        &#125; else &#123;    </div><div class="line">            for (int i = size-1; i &gt;= 0; i--)    </div><div class="line">            if (o.equals(elementData[i]))    </div><div class="line">                return i;    </div><div class="line">        &#125;    </div><div class="line">        return -1;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值    </div><div class="line">    public int lastIndexOf(Object o) &#123;    </div><div class="line">        if (o == null) &#123;    </div><div class="line">            for (int i = size-1; i &gt;= 0; i--)    </div><div class="line">            if (elementData[i]==null)    </div><div class="line">                return i;    </div><div class="line">        &#125; else &#123;    </div><div class="line">            for (int i = size-1; i &gt;= 0; i--)    </div><div class="line">            if (o.equals(elementData[i]))    </div><div class="line">                return i;    </div><div class="line">        &#125;    </div><div class="line">        return -1;    </div><div class="line">    &#125;    </div><div class="line">     </div><div class="line">   </div><div class="line">    // 返回ArrayList的Object数组    </div><div class="line">    public Object[] toArray() &#123;    </div><div class="line">        return Arrays.copyOf(elementData, size);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 返回ArrayList元素组成的数组  </div><div class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;    </div><div class="line">        // 若数组a的大小 &lt; ArrayList的元素个数；    </div><div class="line">        // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中    </div><div class="line">        if (a.length &lt; size)    </div><div class="line">            return (T[]) Arrays.copyOf(elementData, size, a.getClass());    </div><div class="line">   </div><div class="line">        // 若数组a的大小 &gt;= ArrayList的元素个数；    </div><div class="line">        // 则将ArrayList的全部元素都拷贝到数组a中。    </div><div class="line">        System.arraycopy(elementData, 0, a, 0, size);    </div><div class="line">        if (a.length &gt; size)    </div><div class="line">            a[size] = null;    </div><div class="line">        return a;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 获取index位置的元素值    </div><div class="line">    public E get(int index) &#123;    </div><div class="line">        RangeCheck(index);    </div><div class="line">   </div><div class="line">        return (E) elementData[index];    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 设置index位置的值为element    </div><div class="line">    public E set(int index, E element) &#123;    </div><div class="line">        RangeCheck(index);    </div><div class="line">   </div><div class="line">        E oldValue = (E) elementData[index];    </div><div class="line">        elementData[index] = element;    </div><div class="line">        return oldValue;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将e添加到ArrayList中    </div><div class="line">    public boolean add(E e) &#123;    </div><div class="line">        ensureCapacity(size + 1);  // Increments modCount!!    </div><div class="line">        elementData[size++] = e;    </div><div class="line">        return true;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将e添加到ArrayList的指定位置    </div><div class="line">    public void add(int index, E element) &#123;    </div><div class="line">        if (index &gt; size || index &lt; 0)    </div><div class="line">            throw new IndexOutOfBoundsException(    </div><div class="line">            &quot;Index: &quot;+index+&quot;, Size: &quot;+size);    </div><div class="line">   </div><div class="line">        ensureCapacity(size+1);  // Increments modCount!!    </div><div class="line">        System.arraycopy(elementData, index, elementData, index + 1,    </div><div class="line">             size - index);    </div><div class="line">        elementData[index] = element;    </div><div class="line">        size++;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除ArrayList指定位置的元素    </div><div class="line">    public E remove(int index) &#123;    </div><div class="line">        RangeCheck(index);    </div><div class="line">   </div><div class="line">        modCount++;    </div><div class="line">        E oldValue = (E) elementData[index];    </div><div class="line">   </div><div class="line">        int numMoved = size - index - 1;    </div><div class="line">        if (numMoved &gt; 0)    </div><div class="line">            System.arraycopy(elementData, index+1, elementData, index,    </div><div class="line">                 numMoved);    </div><div class="line">        elementData[--size] = null; // Let gc do its work    </div><div class="line">   </div><div class="line">        return oldValue;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除ArrayList的指定元素    </div><div class="line">    public boolean remove(Object o) &#123;    </div><div class="line">        if (o == null) &#123;    </div><div class="line">                for (int index = 0; index &lt; size; index++)    </div><div class="line">            if (elementData[index] == null) &#123;    </div><div class="line">                fastRemove(index);    </div><div class="line">                return true;    </div><div class="line">            &#125;    </div><div class="line">        &#125; else &#123;    </div><div class="line">            for (int index = 0; index &lt; size; index++)    </div><div class="line">            if (o.equals(elementData[index])) &#123;    </div><div class="line">                fastRemove(index);    </div><div class="line">                return true;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        return false;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // 快速删除第index个元素    </div><div class="line">    private void fastRemove(int index) &#123;    </div><div class="line">        modCount++;    </div><div class="line">        int numMoved = size - index - 1;    </div><div class="line">        // 从&quot;index+1&quot;开始，用后面的元素替换前面的元素。    </div><div class="line">        if (numMoved &gt; 0)    </div><div class="line">            System.arraycopy(elementData, index+1, elementData, index,    </div><div class="line">                             numMoved);    </div><div class="line">        // 将最后一个元素设为null    </div><div class="line">        elementData[--size] = null; // Let gc do its work    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除元素    </div><div class="line">    public boolean remove(Object o) &#123;    </div><div class="line">        if (o == null) &#123;    </div><div class="line">            for (int index = 0; index &lt; size; index++)    </div><div class="line">            if (elementData[index] == null) &#123;    </div><div class="line">                fastRemove(index);    </div><div class="line">            return true;    </div><div class="line">            &#125;    </div><div class="line">        &#125; else &#123;    </div><div class="line">            // 便利ArrayList，找到“元素o”，则删除，并返回true。    </div><div class="line">            for (int index = 0; index &lt; size; index++)    </div><div class="line">            if (o.equals(elementData[index])) &#123;    </div><div class="line">                fastRemove(index);    </div><div class="line">            return true;    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        return false;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 清空ArrayList，将全部的元素设为null    </div><div class="line">    public void clear() &#123;    </div><div class="line">        modCount++;    </div><div class="line">   </div><div class="line">        for (int i = 0; i &lt; size; i++)    </div><div class="line">            elementData[i] = null;    </div><div class="line">   </div><div class="line">        size = 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 将集合c追加到ArrayList中    </div><div class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;    </div><div class="line">        Object[] a = c.toArray();    </div><div class="line">        int numNew = a.length;    </div><div class="line">        ensureCapacity(size + numNew);  // Increments modCount    </div><div class="line">        System.arraycopy(a, 0, elementData, size, numNew);    </div><div class="line">        size += numNew;    </div><div class="line">        return numNew != 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 从index位置开始，将集合c添加到ArrayList    </div><div class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;    </div><div class="line">        if (index &gt; size || index &lt; 0)    </div><div class="line">            throw new IndexOutOfBoundsException(    </div><div class="line">            &quot;Index: &quot; + index + &quot;, Size: &quot; + size);    </div><div class="line">   </div><div class="line">        Object[] a = c.toArray();    </div><div class="line">        int numNew = a.length;    </div><div class="line">        ensureCapacity(size + numNew);  // Increments modCount    </div><div class="line">   </div><div class="line">        int numMoved = size - index;    </div><div class="line">        if (numMoved &gt; 0)    </div><div class="line">            System.arraycopy(elementData, index, elementData, index + numNew,    </div><div class="line">                 numMoved);    </div><div class="line">   </div><div class="line">        System.arraycopy(a, 0, elementData, index, numNew);    </div><div class="line">        size += numNew;    </div><div class="line">        return numNew != 0;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    // 删除fromIndex到toIndex之间的全部元素。    </div><div class="line">    protected void removeRange(int fromIndex, int toIndex) &#123;    </div><div class="line">    modCount++;    </div><div class="line">    int numMoved = size - toIndex;    </div><div class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,    </div><div class="line">                         numMoved);    </div><div class="line">   </div><div class="line">    // Let gc do its work    </div><div class="line">    int newSize = size - (toIndex-fromIndex);    </div><div class="line">    while (size != newSize)    </div><div class="line">        elementData[--size] = null;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">    private void RangeCheck(int index) &#123;    </div><div class="line">    if (index &gt;= size)    </div><div class="line">        throw new IndexOutOfBoundsException(    </div><div class="line">        &quot;Index: &quot;+index+&quot;, Size: &quot;+size);    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // 克隆函数    </div><div class="line">    public Object clone() &#123;    </div><div class="line">        try &#123;    </div><div class="line">            ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();    </div><div class="line">            // 将当前ArrayList的全部元素拷贝到v中    </div><div class="line">            v.elementData = Arrays.copyOf(elementData, size);    </div><div class="line">            v.modCount = 0;    </div><div class="line">            return v;    </div><div class="line">        &#125; catch (CloneNotSupportedException e) &#123;    </div><div class="line">            // this shouldn&apos;t happen, since we are Cloneable    </div><div class="line">            throw new InternalError();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // java.io.Serializable的写入函数    </div><div class="line">    // 将ArrayList的“容量，所有的元素值”都写入到输出流中    </div><div class="line">    private void writeObject(java.io.ObjectOutputStream s)    </div><div class="line">        throws java.io.IOException&#123;    </div><div class="line">    // Write out element count, and any hidden stuff    </div><div class="line">    int expectedModCount = modCount;    </div><div class="line">    s.defaultWriteObject();    </div><div class="line">   </div><div class="line">        // 写入“数组的容量”    </div><div class="line">        s.writeInt(elementData.length);    </div><div class="line">   </div><div class="line">    // 写入“数组的每一个元素”    </div><div class="line">    for (int i=0; i&lt;size; i++)    </div><div class="line">            s.writeObject(elementData[i]);    </div><div class="line">   </div><div class="line">    if (modCount != expectedModCount) &#123;    </div><div class="line">            throw new ConcurrentModificationException();    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">    &#125;    </div><div class="line">   </div><div class="line">   </div><div class="line">    // java.io.Serializable的读取函数：根据写入方式读出    </div><div class="line">    // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出    </div><div class="line">    private void readObject(java.io.ObjectInputStream s)    </div><div class="line">        throws java.io.IOException, ClassNotFoundException &#123;    </div><div class="line">        // Read in size, and any hidden stuff    </div><div class="line">        s.defaultReadObject();    </div><div class="line">   </div><div class="line">        // 从输入流中读取ArrayList的“容量”    </div><div class="line">        int arrayLength = s.readInt();    </div><div class="line">        Object[] a = elementData = new Object[arrayLength];    </div><div class="line">   </div><div class="line">        // 从输入流中将“所有的元素值”读出    </div><div class="line">        for (int i=0; i&lt;size; i++)    </div><div class="line">            a[i] = s.readObject();    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>注意trantient关键字，说明修饰变量不参与序列化。注意fail-fast和fail-safe的区别。参考博文：<a href="http://blog.csdn.net/ch717828/article/details/46892051" target="_blank" rel="external">fail-fast和fail-safe</a>。</li>
<li><p>ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。</p>
</li>
<li><p>在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。</p>
</li>
<li>注意其三个不同的构造方法。无参构造方法构造的ArrayList的容量默认为10，带有Collection参数的构造方法，将Collection转化为数组赋给ArrayList的实现数组elementData。</li>
<li>注意扩充容量的方法ensureCapacity。ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍加1，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后用Arrays.copyof()方法将元素拷贝到新的数组（详见下面的第3点）。从中可以看出，当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。</li>
<li>注意arraylist和array的互相转化。toArray()和toArray(T[])。</li>
<li>ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法。我们有必要对这两个方法的实现做下深入的了解。首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123;  </div><div class="line">    return (T[]) copyOf(original, newLength, original.getClass());  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;  </div><div class="line">    T[] copy = ((Object)newType == (Object)Object[].class)  </div><div class="line">        ? (T[]) new Object[newLength]  </div><div class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);  </div><div class="line">    System.arraycopy(original, 0, copy, 0,  </div><div class="line">                     Math.min(original.length, newLength));  </div><div class="line">    return copy;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的,很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型可以很明显地看出，该方法实际上是在其内部又创建了一个长度为newlength的数组，调用System.arraycopy()方法，将原来数组中的元素复制到了新的数组中。</p>
<p>&#160; &#160; &#160; &#160;下面来看System.arraycopy()方法。该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>&#160; &#160; &#160; &#160;LinkedList是基于双向循环链表（从源码中可以很容易看出）实现的，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。LinkedList同样是非线程安全的，只在单线程下适合使用。LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。</p>
<p>&#160; &#160; &#160; &#160;源码解析地址，参考博文：<a href="http://blog.csdn.net/ns_code/article/details/35787253" target="_blank" rel="external">LinkedList源码剖析</a>.</p>
<p>&#160; &#160; &#160; &#160;list集合中还有vector和stack。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在学习map类之后，我们今天了解list接口相关的一些类。本文转自系列博文：&lt;a href=&quot;http://blog.csdn.net/column/details/collection.html?page=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java集合类剖析&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK源码解析" scheme="http://yoursite.com/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK集合类源码" scheme="http://yoursite.com/tags/JDK%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读（二）</title>
    <link href="http://yoursite.com/2017/04/03/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/03/JDK源码阅读（二）/</id>
    <published>2017-04-03T05:57:56.000Z</published>
    <updated>2017-08-04T12:10:23.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在了解了基类和基础数据类型加上字符串的基础上，我们就要开始集合类的学习了，这些就是我们需要经常用到的一些。</p>
 <a id="more"></a>
<h2 id="总体框图"><a href="#总体框图" class="headerlink" title="总体框图"></a>总体框图</h2><p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://opb7t58xj.bkt.clouddn.com/%E9%9B%86%E5%90%88%E7%B1%BB.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;图中就说明了集合类之间的一些关系，包含接口、抽象类和实现类还有继承实现的关系。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&#160; &#160; &#160; &#160;HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了不同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。值得注意的是HashMap不是线程安全的，如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。现在又出现了concurrent包里面的，我们更要知道，在并发情况下更高效。</p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>&#160; &#160; &#160; &#160;HashMap的底层主要是基于<font color="red">数组和链表</font>来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://images.cnitblog.com/blog/400827/201409/041358026259354.jpg" alt=""></p>
<p>&#160; &#160; &#160; &#160;图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。我们看看HashMap中Entry类的代码：　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">/** Entry是单向链表。    </div><div class="line">     * 它是 “HashMap链式存储法”对应的链表。    </div><div class="line">     *它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数  </div><div class="line">    **/  </div><div class="line">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    </div><div class="line">        final K key;    </div><div class="line">        V value;    </div><div class="line">        // 指向下一个节点    </div><div class="line">        Entry&lt;K,V&gt; next;    </div><div class="line">        final int hash;    </div><div class="line">   </div><div class="line">        // 构造函数。    </div><div class="line">        // 输入参数包括&quot;哈希值(h)&quot;, &quot;键(k)&quot;, &quot;值(v)&quot;, &quot;下一节点(n)&quot;    </div><div class="line">        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;    </div><div class="line">            value = v;    </div><div class="line">            next = n;    </div><div class="line">            key = k;    </div><div class="line">            hash = h;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final K getKey() &#123;    </div><div class="line">            return key;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final V getValue() &#123;    </div><div class="line">            return value;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final V setValue(V newValue) &#123;    </div><div class="line">            V oldValue = value;    </div><div class="line">            value = newValue;    </div><div class="line">            return oldValue;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 判断两个Entry是否相等    </div><div class="line">        // 若两个Entry的“key”和“value”都相等，则返回true。    </div><div class="line">        // 否则，返回false    </div><div class="line">        public final boolean equals(Object o) &#123;    </div><div class="line">            if (!(o instanceof Map.Entry))    </div><div class="line">                return false;    </div><div class="line">            Map.Entry e = (Map.Entry)o;    </div><div class="line">            Object k1 = getKey();    </div><div class="line">            Object k2 = e.getKey();    </div><div class="line">            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;    </div><div class="line">                Object v1 = getValue();    </div><div class="line">                Object v2 = e.getValue();    </div><div class="line">                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))    </div><div class="line">                    return true;    </div><div class="line">            &#125;    </div><div class="line">            return false;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 实现hashCode()    </div><div class="line">        public final int hashCode() &#123;    </div><div class="line">            return (key==null   ? 0 : key.hashCode()) ^    </div><div class="line">                   (value==null ? 0 : value.hashCode());    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        public final String toString() &#123;    </div><div class="line">            return getKey() + &quot;=&quot; + getValue();    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 当向HashMap中添加元素时，绘调用recordAccess()。    </div><div class="line">        // 这里不做任何处理    </div><div class="line">        void recordAccess(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">        &#125;    </div><div class="line">   </div><div class="line">        // 当从HashMap中删除元素时，绘调用recordRemoval()。    </div><div class="line">        // 这里不做任何处理    </div><div class="line">        void recordRemoval(HashMap&lt;K,V&gt; m) &#123;    </div><div class="line">        &#125;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;<font color="red">HashMap其实就是一个Entry数组，Entry对象中包含了键和值，其中next也是一个Entry对象，它就是用来处理hash冲突的，形成一个链表。</font>　</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h4><p>&#160; &#160; &#160; &#160;这是hashmap一些重要属性。</p>
<pre><code>transient Entry[] table;//存储元素的实体数组

transient int size;//存放元素的个数

int threshold; //临界值   当实际大小超过临界值时，会进行扩容threshold = 加载因子*容量

final float loadFactor; //加载因子

transient int modCount;//被修改的次数
</code></pre><p>&#160; &#160; &#160; &#160;其中loadFactor加载因子是表示Hsah表中元素的填满的程度.</p>
<p>&#160; &#160; &#160; &#160;若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.链表长度会越来越长,查找效率降低。反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.表中的数据将过于稀疏（很多空间还没用，就开始扩容了）。冲突的机会越大,则查找的成本越高.</p>
<p>&#160; &#160; &#160; &#160;因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的”时-空”矛盾的平衡与折衷.</p>
<p>&#160; &#160; &#160; &#160;如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">        //确保数字合法</div><div class="line">        if (initialCapacity &lt; 0)</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</div><div class="line">                                              initialCapacity);</div><div class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</div><div class="line">                                              loadFactor);</div><div class="line"></div><div class="line">        // Find a power of 2 &gt;= initialCapacity</div><div class="line">        int capacity = 1;   //初始容量</div><div class="line">        while (capacity &lt; initialCapacity)   //确保容量为2的n次幂，使capacity为大于initialCapacity的最小的2的n次幂</div><div class="line">            capacity &lt;&lt;= 1;</div><div class="line"></div><div class="line">        this.loadFactor = loadFactor;</div><div class="line">        threshold = (int)(capacity * loadFactor);</div><div class="line">        table = new Entry[capacity];</div><div class="line">       init();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    public HashMap(int initialCapacity) &#123;</div><div class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    public HashMap() &#123;</div><div class="line">        this.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">        threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</div><div class="line">        table = new Entry[DEFAULT_INITIAL_CAPACITY];</div><div class="line">       init();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;我们可以看到在构造HashMap的时候如果我们指定了加载因子和初始容量的话就调用第一个构造方法，否则的话就是用默认的。默认初始容量为16，默认加载因子为0.75。我们可以看到上面代码中13-15行，这段代码的作用是确保容量为2的n次幂，使capacity为大于initialCapacity的最小的2的n次幂，至于为什么要把容量设置为2的n次幂，我们等下再看。</p>
<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">     // 若“key为null”，则将该键值对添加到table[0]中。</div><div class="line">         if (key == null) </div><div class="line">            return putForNullKey(value);</div><div class="line">     // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。</div><div class="line">         int hash = hash(key.hashCode());</div><div class="line">     //搜索指定hash值在对应table中的索引</div><div class="line">         int i = indexFor(hash, table.length);</div><div class="line">     // 循环遍历Entry数组,若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</div><div class="line">         for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; </div><div class="line">             Object k;</div><div class="line">              if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; //如果key相同则覆盖并返回旧值</div><div class="line">                  V oldValue = e.value;</div><div class="line">                 e.value = value;</div><div class="line">                 e.recordAccess(this);</div><div class="line">                 return oldValue;</div><div class="line">              &#125;</div><div class="line">         &#125;</div><div class="line">     //修改次数+1</div><div class="line">         modCount++;</div><div class="line">     //将key-value添加到table[i]处</div><div class="line">     addEntry(hash, key, value, i);</div><div class="line">     return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;上面程序中用到了一个重要的内部接口：Map.Entry，每个 Map.Entry 其实就是一个 key-value 对。从上面程序中可以看出：当系统决定存储 HashMap 中的 key-value 对时，完全没有考虑 Entry 中的 value，仅仅只是根据 key 来计算并决定每个 Entry 的存储位置。这也说明了前面的结论：我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p>
<p>&#160; &#160; &#160; &#160;注意：第2和3行的作用就是处理key值为null的情况,如果key为null的话，hash值为0，对象存储在数组中索引为0的位置。即table[0].我们再回去看看put方法中第4行，它是通过key的hashCode值计算hash码,得到hash码之后就会通过hash码去计算出应该存储在数组中的索引,这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">private V putForNullKey(V value) &#123;</div><div class="line">        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</div><div class="line">            if (e.key == null) &#123;   //如果有key为null的对象存在，则覆盖掉</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(this);</div><div class="line">                return oldValue;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">        modCount++;</div><div class="line">        addEntry(0, null, value, 0); //如果键为null的话，则hash值为0</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //计算hash值的方法 通过键的hashCode来计算</div><div class="line">    static int hash(int h) &#123;</div><div class="line">        // This function ensures that hashCodes that differ only by</div><div class="line">        // constant multiples at each bit position have a bounded</div><div class="line">        // number of collisions (approximately 8 at default load factor).</div><div class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</div><div class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    static int indexFor(int h, int length) &#123; //根据hash值和数组长度算出索引值</div><div class="line">       //这里不能随便算取，用hash&amp;(length-1)是有原因的，</div><div class="line">       //这样可以确保算出来的索引是在数组大小范围内，不会超出</div><div class="line">         return h &amp; (length-1);  </div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">         //如果要加入的位置有值，将该位置原先的值设置为新entry的next,</div><div class="line">        //也就是新entry链表的下一个节点</div><div class="line">        Entry&lt;K,V&gt; e = table[bucketIndex]; </div><div class="line">        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        if (size++ &gt;= threshold) //如果大于临界值就扩容</div><div class="line">            resize(2 * table.length); //以2的倍数扩容</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;参数bucketIndex就是indexFor函数计算出来的索引值，第2行代码是取得数组中索引为bucketIndex的Entry对象，第3行就是用hash、key、value构建一个新的Entry对象放到索引为bucketIndex的位置，并且将该位置原先的对象设置为新对象的next构成链表。第4行和第5行就是判断put后size是否达到了临界值threshold，如果达到了临界值就要进行扩容，HashMap扩容是扩为原来的两倍。resize()如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void resize(int newCapacity) &#123;</div><div class="line">        Entry[] oldTable = table;</div><div class="line">        int oldCapacity = oldTable.length;</div><div class="line">        if (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">        Entry[] newTable = new Entry[newCapacity];</div><div class="line">        transfer(newTable);//用来将原先table的元素全部移到newTable里面</div><div class="line">        table = newTable;  //再将newTable赋值给table</div><div class="line">        threshold = (int)(newCapacity * loadFactor);//重新计算临界值</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;新建了一个HashMap的底层数组，上面代码中第10行为调用transfer方法，将HashMap的全部元素添加到新的HashMap中,并重新计算元素在新的数组中的索引位置</p>
<p>&#160; &#160; &#160; &#160;当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>&#160; &#160; &#160; &#160;那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小 x loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16 x 0.75=12的时候，就把数组的大小扩展为 2 x 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，扩容是需要进行数组复制的，复制数组是非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;   </div><div class="line">    if (key == null)   </div><div class="line">        return getForNullKey();   </div><div class="line">    int hash = hash(key.hashCode());   </div><div class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];   </div><div class="line">        e != null;   </div><div class="line">        e = e.next) &#123;   </div><div class="line">        Object k;   </div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))   </div><div class="line">            return e.value;   </div><div class="line">    &#125;   </div><div class="line">    return null;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
<p>本文转自博文：<a href="http://www.cnblogs.com/ITtangtang/p/3948406.html" target="_blank" rel="external">Java集合—HashMap源码剖析</a>，感谢博主的总结。我们还可以从面试官的角度去想问题：参考<a href="http://www.importnew.com/7099.html" target="_blank" rel="external">HashMap的工作原理</a>。</p>
<h2 id="其他的map实现"><a href="#其他的map实现" class="headerlink" title="其他的map实现"></a>其他的map实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.TreeMap;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by xus on 2017/4/03.</div><div class="line"> */</div><div class="line">public class mapDemo &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        hashmap();</div><div class="line"></div><div class="line">        treemap();</div><div class="line">        </div><div class="line">        linkedmap();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //按key排序；</div><div class="line">    public static void treemap()&#123;</div><div class="line">        TreeMap&lt;String , Double&gt; map =  new TreeMap&lt;String , Double&gt;();</div><div class="line">        map.put(&quot;ccc&quot; , 89.0);</div><div class="line">        map.put(&quot;aaa&quot; , 80.0);</div><div class="line">        map.put(&quot;zzz&quot; , 80.0);</div><div class="line">        map.put(&quot;bbb&quot; , 89.0);</div><div class="line">        System.out.println(map);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void hashmap()&#123;</div><div class="line">        HashMap&lt;String,Double&gt; map=new HashMap&lt;&gt;();</div><div class="line">        map.put(&quot;ccc&quot; , 89.0);</div><div class="line">        map.put(&quot;aaa&quot; , 80.0);</div><div class="line">        map.put(&quot;zzz&quot; , 80.0);</div><div class="line">        map.put(&quot;bbb&quot; , 89.0);</div><div class="line">        System.out.println(map);</div><div class="line">    &#125;</div><div class="line">       public static void linkedmap()&#123;</div><div class="line">        LinkedHashMap&lt;String,Double&gt; map=new LinkedHashMap&lt;&gt;();</div><div class="line">        map.put(&quot;ccc&quot; , 89.0);</div><div class="line">        map.put(&quot;aaa&quot; , 80.0);</div><div class="line">        map.put(&quot;zzz&quot; , 80.0);</div><div class="line">        map.put(&quot;bbb&quot; , 89.0);</div><div class="line">        System.out.println(map);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;对于LinkedHashMap，输出顺序和插入顺序一样；对于hashmap，顺序是随机的；对于treemap。当程序执行 map.put(“ccc” , 89.0); 时，系统将直接把 “ccc”-89.0 这个 Entry 放入 Map 中，这个 Entry 就是该“红黑树”的根节点。接着程序执行 map.put(“aaa” , 80.0); 时，程序会将 “aaa”-80.0 作为新节点添加到已有的红黑树中。以后每向 TreeMap 中放入一个 key-value 对，系统都需要将该 Entry 当成一个新节点，添加成已有红黑树中，通过这种方式就可保证 TreeMap 中所有 key 总是按某种规则排列。例如我们输出上面程序，将看到如下结果（所有 key 由小到大地排列）：</p>
<pre><code>{aaa=80.0, ccc=89.0, bbb=89.0, zzz=80.0}
{aaa=80.0, bbb=89.0, ccc=89.0, zzz=80.0}
{ccc=89.0, aaa=80.0, zzz=80.0, bbb=89.0}
</code></pre><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>&#160; &#160; &#160; &#160;TreeMap 的实现使用了红黑树数据结构，也就是一棵自平衡的排序二叉树，这样就可以保证快速检索指定节点。对于 TreeMap 而言，它采用一种被称为“红黑树”的排序二叉树来保存 Map 中每个 Entry —— 每个 Entry 都被当成“红黑树”的一个节点对待。</p>
<p>&#160; &#160; &#160; &#160;TreeMap、TreeSet 比 HashMap、HashSet 的优势在于：TreeMap 中的所有 Entry 总是按 key 根据指定排序规则保持有序状态，TreeSet 中所有元素总是根据指定排序规则保持有序状态。但是插入性能变低。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>&#160; &#160; &#160; &#160;输出顺序按输入顺序一样，是hashmap的一个子类,也允许一个null的key。</p>
<p><img src="http://img.blog.csdn.net/20140716084631981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnNfY29kZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><img src="http://img.blog.csdn.net/20140716084409234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnNfY29kZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&#160; &#160; &#160; &#160; 关于LinkedHashMap的源码，给出以下几点比较重要的总结：</p>
<ul>
<li>从源码中可以看出，LinkedHashMap中加入了一个head头结点，将所有插入到该LinkedHashMap中的Entry按照插入的先后顺序依次加入到以head为头结点的双向循环链表的尾部。</li>
</ul>
<ul>
<li>实际上就是HashMap和LinkedList两个集合类的存储结构的结合。在LinkedHashMapMap中，所有put进来的Entry都保存在如第一个图所示的哈希表中，但它又额外定义了一个以head为头结点的空的双向循环链表，每次put进来Entry，除了将其保存到对哈希表中对应的位置上外，还要将其插入到双向循环链表的尾部。</li>
</ul>
<ul>
<li>注意源码中的accessOrder标志位，当它false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序；当它为true时，表示双向链表中的元素按照访问的先后顺序排列，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同，覆盖原有的Entry的情况下调用recordAccess方法），该方法判断accessOrder是否为true，如果是，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用creatEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了），否则，什么也不做。</li>
</ul>
<ul>
<li>注意构造方法，前四个构造方法都将accessOrder设为false，说明默认是按照插入顺序排序的，而第五个构造方法可以自定义传入的accessOrder的值，因此可以指定双向循环链表中元素的排序规则，一般要用LinkedHashMap实现LRU算法，就要用该构造方法，将accessOrder置为true。</li>
</ul>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>&#160; &#160; &#160; &#160;现在使用的较少了，是hashtable的线程安全版本，且不允许插入null值，效率较低，我们后面重点介绍concurrent包里面的效率较高的map。这里针对Hashtable，我们同样给出几点比较重要的总结，但要结合与HashMap的比较来总结。</p>
<ol>
<li>二者的存储结构和解决冲突的方法都是相同的。</li>
<li>HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。</li>
<li>Hashtable中key和value都不允许为null，而HashMap中key和value都允许为null</li>
<li>Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。</li>
<li>Hashtable计算hash值，直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>共同点：</p>
<p>&#160; &#160; &#160; &#160;HashMap,LinkedHashMap,TreeMap都属于Map；Map 主要用于存储键(key)值(value)对，根据键得到值，因此键不允许键重复,但允许值重复。还有不常用的weakHashMap和identityHashMap。  </p>
<p>不同点：</p>
<ol>
<li>HashMap里面存入的键值对在取出的时候是随机的,也是我们最常用的一个Map.它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。  </li>
<li>TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。  </li>
<li>LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现.  (应用场景：购物车等需要顺序的)<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在了解了基类和基础数据类型加上字符串的基础上，我们就要开始集合类的学习了，这些就是我们需要经常用到的一些。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK源码解析" scheme="http://yoursite.com/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK集合类源码" scheme="http://yoursite.com/tags/JDK%E9%9B%86%E5%90%88%E7%B1%BB%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>实现简易web服务器和web浏览器</title>
    <link href="http://yoursite.com/2017/04/02/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cweb%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/04/02/web服务器和web浏览器的实现原理/</id>
    <published>2017-04-02T04:31:39.000Z</published>
    <updated>2017-07-26T11:46:22.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web服务器和web浏览器的实现原理"><a href="#web服务器和web浏览器的实现原理" class="headerlink" title="web服务器和web浏览器的实现原理"></a>web服务器和web浏览器的实现原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;预警：此篇篇幅很长，可通过菜单导航观看。最近在复习计算机网络的知识，因为想在Java web方面深入了解，所以在思考B／S结构模式的工作是怎样的过程呢，刚好找了好些资料和别人的总结，现在把这些都整理一下。在基础中已经学习了socket和http协议，我们也知道通过浏览器输入一个地址，访问一个网页的操作。实际对应的底层操作简单来说就是：客户端(浏览器)面向于WEB服务器的网络通信。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;那么，既然是网络通信。对应于Java当中来说，就自然离不开Socket与IO流。其实这也正是Web服务器与浏览器的基础实现原理。当然，想要开发一套完善的WEB服务器或浏览器，需要做的工作是很复杂的，要考虑多线程、并发、io流、网络等等。但我们想要了解的只是其原理。后面将对使用较多的servlet和tomcat在进行分析，达到一个比较深入的理解。本篇在此博客基础上进一步整理：<a href="http://blog.csdn.net/ghost_programmer/article/details/43446531" target="_blank" rel="external">浅析web服务器与浏览器的实现原理</a>。</p>
<h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>&#160; &#160; &#160; &#160;我们知道，将开发的web项目部署到tomcat服务器之后，就可以通过浏览器对服务器上的资源进行访问。但重要的一点是，存在多种不同厂商开发的不同浏览器。但各个类型的WEB浏览器，都可以正常的访问tomcat服务器上的资源。对此，我们可以这样理解：我开发了一个WEB服务器，并且能够保证其他人开发的客户端都能够与我的服务器正常通信。</p>
<p>&#160; &#160; &#160; &#160;能够实现这样的目的的前提自然就是，你要制定一个规范，并让想要与你开发的服务器正常进行通信的客户端都遵循这个规范来实现。这个规范，也就是所谓的协议。</p>
<p>&#160; &#160; &#160; &#160;正如在网络通信中，数据的传输可以遵循TCP/IP或UDP协议一样。WEB服务器与WEB浏览器之间，也通过一种双方都熟悉的语言进行通信。这种协议即是：超文本传输协议，也就是HTTP协议。不同的是，TCP/IP与UDP议是传输层当中的通信协议，而HTTP协议是应用层当中的协议。</p>
<p>&#160; &#160; &#160; &#160;当我们想要使用Java语言实现所谓的WEB通信，自然也应当遵循HTTP协议。Java中已经为我们提供了这样的一种实现规范，也就是广为人知的：Servlet接口。而我们开发web项目时,最常用到的HttpServlet类，就是基于此接口实现的具体子类。该类封装和提供了，针对基于Http协议通信的内容进行访问和操作的常用方法。</p>
<h2 id="Servlet实例"><a href="#Servlet实例" class="headerlink" title="Servlet实例"></a>Servlet实例</h2><p>&#160; &#160; &#160; &#160;首先，我们通过一段简单的Servlet代码来看一下，基于HTTP协议进行WEB通信的请求信息。我的环境是os x+idea+tomcat7，项目工程我放在github上，链接传送门：<a href="https://github.com/wustzoujing/MyBrowerAndMyTomcat" target="_blank" rel="external">wustzoujing/MyBrowerAndMyTomcat</a>。</p>
<p>&#160; &#160; &#160; &#160;首先要了解servlet，这个基础没有的话，可以参考这个入门教程<a href="http://www.runoob.com/servlet/servlet-tutorial.html" target="_blank" rel="external">servlet教程</a>。从helloworld开始做。这里我们基于HttpServlet+Tomcat，先建立一个web的项目，再写servlet测试类，然后配置web.xml，最后用tomcat发布。</p>
<p>&#160; &#160; &#160; &#160;这里贴上一些代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import javax.servlet.http.*;</div><div class="line">import javax.servlet.*;</div><div class="line">import java.io.IOException;</div><div class="line">import java.util.Enumeration;</div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line">public class ServeletTest extends HttpServlet &#123;</div><div class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response)</div><div class="line">            throws ServletException, IOException &#123;</div><div class="line">        for (Enumeration e = request.getHeaderNames(); e.hasMoreElements();) &#123;</div><div class="line">            String header = (String) e.nextElement();</div><div class="line">            if (header != null)</div><div class="line">                System.out.println((new StringBuilder(String.valueOf(header)))</div><div class="line">                        .append(&quot;:&quot;).append(request.getHeader(header))</div><div class="line">                        .toString());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">            throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;接下来是web.xml的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</div><div class="line">           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">           xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</div><div class="line">		  http://java.sun.com/xml/ns/javaee/web-app_3_1.xsd&quot;</div><div class="line">           version=&quot;3.0&quot;&gt;</div><div class="line"></div><div class="line"></div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;TomcatWeb&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;ServeletTest&lt;/servlet-class&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line"></div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;TomcatWeb&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/servlet/HttpServletDemo&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line">&lt;/web-app&gt;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;当我们在浏览器输入链接<a href="http://localhost:8080/servlet/HttpServletDemo的时候，会打印出下面信息：" target="_blank" rel="external">http://localhost:8080/servlet/HttpServletDemo的时候，会打印出下面信息：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">host:localhost:8080</div><div class="line">accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">upgrade-insecure-requests:1</div><div class="line">cookie:JSESSIONID=92E7AE4F85499378342793886884D0C0; _ga=GA1.1.1073505442.1486722778</div><div class="line">user-agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.1 Safari/603.1.30</div><div class="line">accept-language:zh-cn</div><div class="line">accept-encoding:gzip, deflate</div><div class="line">connection:keep-alive</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;在计算机网络的学习中我们就知道了，这是http请求报文的内容，我们这里再回忆一下：一个HTTP协议的请求中，通常主要包含三个部分：</p>
<ol>
<li>方法/统一资源标示符(URI)/协议/版本 </li>
<li>请求标头</li>
<li>实体主体</li>
</ol>
<p>&#160; &#160; &#160; &#160;其中方法也就是所谓的get/post之类的请求方法，统一资源标示符也就是要访问的目标资源的路径，包括协议及协议版本，这些信息被放在请求的第一行。</p>
<p>&#160; &#160; &#160; &#160;随后，紧接着的便是请求标头；请求标头通常包含了与客户端环境及请求实体主体相关的有用信息。</p>
<p>&#160; &#160; &#160; &#160;最后，在标头与实体主体之间是一个空行。它对于HTTP请求格式是很重要的，空行告诉HTTP服务器，实体主体从这里开始。</p>
<h2 id="实现最简易的Tomcat"><a href="#实现最简易的Tomcat" class="headerlink" title="实现最简易的Tomcat"></a>实现最简易的Tomcat</h2><p>&#160; &#160; &#160; &#160;前面已经说过了，我们这里想要研究的，是WEB服务器的基本实现原理。那么我们自然想要自己来实现一下所谓的WEB服务器，我们已经知道了：所谓的B/S结构，实际上就是客户端与服务器之间基于HTTP协议的网络通信。那么，肯定是离不开socket与io的，所以我们可以简单的模拟一个最简易功能的web服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyTomcat &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            ServerSocket tomcat = new ServerSocket(9090);</div><div class="line">            System.out.println(&quot;服务器启动&quot;);</div><div class="line">            //</div><div class="line">            Socket s = tomcat.accept();</div><div class="line">            //</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            InputStream in = s.getInputStream();</div><div class="line">            //</div><div class="line">            int length = in.read(buf);</div><div class="line">            String request = new String(buf,0,length);</div><div class="line">            //</div><div class="line">            System.out.println(request);</div><div class="line">            </div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line"></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="demo中所需理论"><a href="#demo中所需理论" class="headerlink" title="demo中所需理论"></a>demo中所需理论</h3><p>&#160; &#160; &#160; &#160;demo中我们用到了ServerSocket和Socket，这也是Java网络编程中必须知道的，分别使用与服务器端和客户端。下面我们看下区别：</p>
<h4 id="serverSocket类"><a href="#serverSocket类" class="headerlink" title="serverSocket类"></a>serverSocket类</h4><p>&#160; &#160; &#160; &#160;创建一个ServerSocket类，同时在运行该语句的计算机的指定端口处建立一个监听服务，如：上面的ServerSocket tomcat = new ServerSocket(9090);这里指定提供监听服务的端口是9090，一台计算机可以同时提供多个服务，这些不同的服务之间通过端口号来区别，不同的端口号上提供不同的服务。</p>
<p>&#160; &#160; &#160; &#160;为了随时监听可能的Client请求，执行如下的语句：Socket s = tomcat.accept();该语句调用了ServerSocket对象的accept()方法，这个方法的执行将使Server端的程序处于等待状态，程序将一直阻塞直到捕捉到一个来自Client端的请求，并返回一个用于与该Client通信的Socket对象Link-Socket。此后Server程序只要向这个Socket对象读写数据，就可以实现向远端的Client读写数据。结束监听时，关闭ServerSocket对象：如tomcat.close()；</p>
<h4 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h4><p>&#160; &#160; &#160; &#160;当Client程序需要从Server端获取信息及其他服务时，应创建一个Socket对象：Socket MySocket=new Socket(“ServerComputerName”，600)；</p>
<p>&#160; &#160; &#160; &#160;Socket类的构造函数有两个参数，第一个参数是欲连接到的Server计算机的主机地址，第二个参数是该Server机上提供服务的端口号。Socket对象建立成功之后，就可以在Client和Server之间建立一个连接，并通过这个连接在两个端点之间传递数据。利用Socket类的方法getOutputStream()和getInputStream()分别获得向Socket读写数据的输入／输出流，最后将从Server端读取的数据重新返还到Server端。</p>
<p>&#160; &#160; &#160; &#160;当Server和Client端的通信结束时，可以调用Socket类的close()方法关闭Socket，拆除连接。ServerSocket 一般仅用于设置端口号和监听，真正进行通信的是服务器端的Socket与客户端的Socket，在ServerSocket 进行accept之后，就将主动权转让了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&#160; &#160; &#160; &#160;服务器端程序设计：</p>
<p>&#160; &#160; &#160; &#160;在服务器端，利用ServerSocket类的构造函数ServerSocket(int port)创建一个ServerSocket类的对象，port参数传递端口，这个端口就是服务器监听连接请求的端口，如果在这时出现错误将抛出IOException异常对象，否则将创建ServerSocket对象并开始准备接收连接请求。</p>
<p>&#160; &#160; &#160; &#160;服务程序从调用ServerSocket的accept()方法开始，直到连接建立。在建立连接后，accept()返回一个最近创建的Socket对象，该Socket对象绑定了客户程序的IP地址或端口号。</p>
<p>&#160; &#160; &#160; &#160;客户端程序设计：</p>
<p>&#160; &#160; &#160; &#160;当客户程序需要与服务器程序通信时，需在客户机创建一个Socket对象。Socket类有构造函数Socket(InetAddress addr，int port)和Socket(String host，intport)，两个构造函数都创建了一个基于Socket的连接服务器端流套接字的流套接字。对于第一个InetAd-dress子类对象通过addr参数获得服务器主机的IP地址，对于第二个函数host参数包被分配到InetAddress对象中，如果没有IP地址与host参数相一致，那么将抛出UnknownHostException异常对象。两个函数都通过参数port获得服务器的端口号。假设已经建立连接了，网络API将在客户端基于Socket的流套接字中捆绑客户程序的IP地址和任意一个端口号，否则两个函数都会抛出一个IOException对象。</p>
<p>&#160; &#160; &#160; &#160;如果创建了一个Socket对象，那么它可通过get-InputStream()方法从服务程序获得输入流读传送来的信息，也可通过调用getOutputStream()方法获得输出流来发送消息。在读写活动完成之后，客户程序调用close()方法关闭流和流套接字。</p>
<h3 id="分析demo"><a href="#分析demo" class="headerlink" title="分析demo"></a>分析demo</h3><p>&#160; &#160; &#160; &#160;在demo中，我们开启一个服务器socket来监听9090端口，所以我们在通过在浏览器中输入<a href="http://localhost:9090，进行访问，经过我们demo可以得到的输出结果如下：" target="_blank" rel="external">http://localhost:9090，进行访问，经过我们demo可以得到的输出结果如下：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">服务器启动</div><div class="line">GET / HTTP/1.1</div><div class="line">Host: localhost:9090</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">Cookie: JSESSIONID=92E7AE4F85499378342793886884D0C0; _ga=GA1.1.1073505442.1486722778</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.1 Safari/603.1.30</div><div class="line">Accept-Language: zh-cn</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;通过成果我们看到，我们已经成功的实现了最简易的tomcat。不过这里需要注意的是，我们自己山寨的tomcat服务器当中，之所以也成功的输出了Http协议的请求体，是因为：我们是通过web浏览器进行访问的，如果通过普通的socket进行对serversocket的连接访问，是没有这些请求信息的。因为我们前面已经说过了，web浏览器与服务器之间的通信必须遵循Http协议。</p>
<h2 id="实现简易浏览器"><a href="#实现简易浏览器" class="headerlink" title="实现简易浏览器"></a>实现简易浏览器</h2><p>&#160; &#160; &#160; &#160;通过前面的学习，我相信我们现在更想把浏览器功能也实现，剖析一下，接下来我们就试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.PrintWriter;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line">public class MyBrower &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            Socket browser = new Socket(&quot;127.0.0.1&quot;, 9090);</div><div class="line">            PrintWriter pw = new PrintWriter(browser.getOutputStream(),true);</div><div class="line">            // 封装请求第一行</div><div class="line">            pw.println(&quot;GET/ HTTP/1.1&quot;);</div><div class="line">            // 封装请求头</div><div class="line">            pw.println(&quot;User-Agent: Java/1.8.0_131&quot;);</div><div class="line">            pw.println(&quot;Host: 127.0.0.1:9090&quot;);</div><div class="line">            pw.println(&quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;);</div><div class="line">            pw.println(&quot;Connection: keep-alive&quot;);</div><div class="line">            // 空行</div><div class="line">            pw.println();</div><div class="line">            // 封装实体主体</div><div class="line">            pw.println(&quot;UserName=JessieZou&amp;Age=22&quot;);</div><div class="line">            // 写入完毕</div><div class="line">            browser.shutdownOutput();</div><div class="line"></div><div class="line"></div><div class="line">            // 接受服务器返回信息，</div><div class="line">            InputStream in = browser.getInputStream();</div><div class="line">            //</div><div class="line">            int length = 0;</div><div class="line">            StringBuffer request = new StringBuffer();</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            //</div><div class="line">            while ((length = in.read(buf)) != -1) &#123;</div><div class="line">                String line = new String(buf, 0, length);</div><div class="line">                request.append(line);</div><div class="line">            &#125;</div><div class="line">            System.out.println(request);</div><div class="line">            //browser.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            System.out.println(&quot;亲，出现了异常哦!&quot;);</div><div class="line">        &#125;finally&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;同时改进我们的tomcat如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.PrintWriter;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line"></div><div class="line">public class MyTomcat &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            ServerSocket tomcat = new ServerSocket(9090);</div><div class="line">            System.out.println(&quot;服务器启动&quot;);</div><div class="line">            //</div><div class="line">            Socket s = tomcat.accept();</div><div class="line">            //</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            InputStream in = s.getInputStream();</div><div class="line">            //</div><div class="line"></div><div class="line">            int length = 0;</div><div class="line">            StringBuffer request = new StringBuffer();</div><div class="line">            while ((length = in.read(buf)) != -1) &#123;</div><div class="line">                String line = new String(buf, 0, length);</div><div class="line">                request.append(line);</div><div class="line">            &#125;</div><div class="line">            //</div><div class="line">            System.out.println(&quot;request:&quot;+request);</div><div class="line"></div><div class="line">            PrintWriter pw = new PrintWriter(s.getOutputStream(),true);</div><div class="line">            pw.println(&quot;&lt;html&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;head&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;title&gt;LiveSession List&lt;/title&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;/head&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;body&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;p style=\&quot;font-weight: bold;color: red;\&quot;&gt;welcome to MyTomcat&lt;/p&gt;&quot;);</div><div class="line">            pw.println(&quot;&lt;/body&gt;&quot;);</div><div class="line">            s.close();</div><div class="line">            tomcat.close();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>&#160; &#160; &#160; &#160;响应行和响应标头当中，实际上是负责将相关的一些有用信息返回给我们，但这部分是不需要在浏览器中所展示的。也就是说，我们的浏览器除了应当具备获取一个完整的HTTP响应的能力之外，还应该具备解析HTTP协议响应的能力。事实上，Java也为我们提供了这样的对象，那就是URL及URLConnection对象。</p>
<p>如果我们在我们的浏览器中，植入这样的对象，来进行与服务器之间的HTTP通信，那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.net.HttpURLConnection;</div><div class="line">import java.net.*;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by zoujing on 2017/5/10.</div><div class="line"> */</div><div class="line">public class MyBrowser2 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        try &#123;</div><div class="line">            URL url = new URL(&quot;http://localhost:9090&quot;);</div><div class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line"></div><div class="line">            InputStream in = conn.getInputStream();</div><div class="line">            byte[] buf = new byte[1024];</div><div class="line">            int length = 0;</div><div class="line">            StringBuffer text = new StringBuffer();</div><div class="line">            String line = null;</div><div class="line">            while ((length = in.read(buf)) != -1) &#123;</div><div class="line">                line = new String(buf, 0, length);</div><div class="line">                text.append(line);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            System.out.println(text);</div><div class="line"></div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这次当我们再运行程序，查看输出信息，发现我们从URLConnection对象获取到的输入流当中，读取的响应信息，就如我们所愿的，只剩下了需要被解析显示在页面的响应实体的内容。实际上这也就是Java为我们提供的对象，将对HTTP协议内容的解析功能进行了封装。而究其根本来说，我们基本可以想象到，URLConnection = Socket + HTTP协议解析器。也就是说，该对象的底层除了通过Socket连接到WEB服务器之外，还封装了对HTTP协议内容的解析功能。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>&#160; &#160; &#160; &#160;我们先启动服务器，然后运行浏览器模拟网页浏览的过程，首先看到服务器端收到的请求信息，打印出来的信息和上面类似，我们这里就是把请求报文显示出来。</p>
<p>&#160; &#160; &#160; &#160;紧接着，服务器收到请求进行处理后，返回资源给浏览器，于是得到输出信息，在改进后的tomcat服务器，我们封装了html，不过是静态的。如果在搭配html解析，就可以像我们浏览器一样，能先到解析的页面。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-10%20%E4%B8%8B%E5%8D%883.39.20.png" alt=""></p>
<p>　　现在我们是单线程单连接，而且没有前段操作界面的实现，我们真正使用的tomcat和浏览器当然在多线程并发、io、网络、人性化操作等方面也做了大量工作进行效率优化和简化操作，美化界面。我们通过例子是去了解基本底层原理。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>　　文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;web服务器和web浏览器的实现原理&quot;&gt;&lt;a href=&quot;#web服务器和web浏览器的实现原理&quot; class=&quot;headerlink&quot; title=&quot;web服务器和web浏览器的实现原理&quot;&gt;&lt;/a&gt;web服务器和web浏览器的实现原理&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;预警：此篇篇幅很长，可通过菜单导航观看。最近在复习计算机网络的知识，因为想在Java web方面深入了解，所以在思考B／S结构模式的工作是怎样的过程呢，刚好找了好些资料和别人的总结，现在把这些都整理一下。在基础中已经学习了socket和http协议，我们也知道通过浏览器输入一个地址，访问一个网页的操作。实际对应的底层操作简单来说就是：客户端(浏览器)面向于WEB服务器的网络通信。&lt;/p&gt;
    
    </summary>
    
      <category term="Java Web" scheme="http://yoursite.com/categories/Java-Web/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码阅读（一）</title>
    <link href="http://yoursite.com/2017/04/01/JDK%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/04/01/JDK源码阅读（一）/</id>
    <published>2017-04-01T02:01:12.000Z</published>
    <updated>2017-08-02T08:24:33.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;看JDK的源码是非常有效的学习方法，对深入学习和理解起着关键作用，要保持阅读源码的习惯，之后我们会经常对一些重要的源码进行整理，之前已经看了集合类，今天从基本类型开始，关键是多看，每次看都有新发现，这里主要列出别人整理过的深层次理解，方便自己经常结合源码看。</p>
 <a id="more"></a>
<p>&#160; &#160; &#160; &#160;我们运行的demo的时候，肯定想看自己的结果，所以首先的基础内容就是java的格式化输出，包括保留几位小数啦、进制之间的转换，不同类型之间的转化啦。这里就给几个整理的非常好的总结博客：<a href="http://blog.csdn.net/lonely_fireworks/article/details/7962171/" target="_blank" rel="external">String.format的用法</a>、<a href="http://www.cnblogs.com/huhx/p/javaFormatter.html" target="_blank" rel="external">Formatter的用法</a>、<a href="http://blog.csdn.net/feiyudiaoling/article/details/51354413" target="_blank" rel="external">Java基础类型和字符串之间的转化</a>。而且我们看源码，不是看了就懂的，作为准备得有一定的基础知识的补充才行，补充之后在进行一定拓展我这里就按照这种方式，整理出一个系统完全的学习笔记。每个类的测试demo，我放在了Github上，传送门：<a href="">wustzoujing/Java_Learning</a>.</p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>&#160; &#160; &#160; &#160;Java中所有的类都有一个共同的祖先，它就是Object类，我们首先就学习它。他有12个成员方法。按照用途如下：构造函数 ；hashCode和equals函数用来判断对象是否相同;wait(), wait(long), wait(long,int), notify(), notifyAll() ;toString()和getClass； clone() 用途是用来另存一个当前存在的对象。；finalize() 用于在垃圾回收；</p>
<p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;<img src="http://img.blog.csdn.net/20161205181623207" alt=""></p>
<p>这里是整理的博客，和应该关注的重点！！！</p>
<p><a href="http://www.cnblogs.com/langtianya/archive/2013/01/31/2886572.html" target="_blank" rel="external">全方法注释解析</a>。源码上英文注释，我们试着翻译一下。注意native方法。   </p>
<p><a href="http://blog.csdn.net/liuyanbohome/article/details/8899964" target="_blank" rel="external">equal和==、hashcode</a> String和hashmap等重写了这两个方法，必须一起重写，理由和怎么写？看博客。  </p>
<p><a href="http://blog.csdn.net/zhangjg_blog/article/details/18369201" target="_blank" rel="external">clone。浅拷贝和深拷贝</a>  这是C++里面重要的概念，因为C++中要delete，自己回收，而java不用。</p>
<p><a href="http://longdick.iteye.com/blog/453615" target="_blank" rel="external">wait notify notifyall实例</a>    理解这三个函数的作用。</p>
<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><p>&#160; &#160; &#160; &#160;我们这里拿Integer类来学习Java中的基本数据类型，在JDK源码中有大量的位运算和空间换时间的设计来优化速度。下面是整理的重点知识。</p>
<p><a href="http://blog.csdn.net/javazejian/article/details/51192130" target="_blank" rel="external">Java中参数传递</a>。这个是在运行自己写的交换函数的时候发现的问题。Java中其实都是值传递，都是栈空间中的，要么是基本类型，要么是引用类型，就是一个地址。</p>
<p><a href="http://blog.csdn.net/morewindows/article/details/7354571" target="_blank" rel="external">位运算总结</a>。位运算有判断奇偶、交换两数、变换符号及求绝对值等上的小技巧。源码在项目上。</p>
<p><a href="http://blog.csdn.net/mazhimazh/article/details/16799925" target="_blank" rel="external">Java中的数据类型</a>。基本分类和引用类型及详细介绍。</p>
<p><a href="http://blog.csdn.net/mazhimazh/article/details/17684701" target="_blank" rel="external">Integer类源码解读(一)</a></p>
<p><a href="http://blog.csdn.net/mazhimazh/article/details/17681787" target="_blank" rel="external">Integer类源码解读(二)</a></p>
<h2 id="String-StringBuffer-StringBuiler"><a href="#String-StringBuffer-StringBuiler" class="headerlink" title="String\StringBuffer\StringBuiler"></a>String\StringBuffer\StringBuiler</h2><p>&#160; &#160; &#160; &#160;String被final修饰的，不可变的，重写了hashcode和equal方法，compareTo方法。首先来看一下字符串常见的几个问题：</p>
<p>（1）String s = new String(“xyz”);创建了几个String 对象？<br>&#160; &#160; &#160; &#160;两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个，类似与缓存Byte数值的-128~127数值。New String每写一遍，就创建一个新的对象，那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。</p>
<p>&#160; &#160; &#160; &#160;所以，凡是通过构造器创建的对象都会进行内存分配，所以他就不会指向缓存池中已有的对象而指向新的对象，这样就会造成缓存池中存在多个值相同的字符串对象，浪费资源。所以一般要直接为字符串指定值即可。</p>
<p>&#160; &#160; &#160; &#160;这里需要介绍一下缓存池：为了节省内存，提高资源的复用，jvm引入了常量池这个概念，它属于方法区的一部分，作用之一就是存放编译期间生产的各种字面量和符号引用。方法区的垃圾回收行为是比较少出现的，该区中的对象基本不会被回收，可以理解成是永久存在的。</p>
<p>（2）String s=”a”+”b”+”c”+”d”;创建了几个String对象？<br>&#160; &#160; &#160; &#160;一个，因为Javac在做编译时已经对这些字符串进行了合并操作，预先做了优化处理。</p>
<p>（3）String name = “ab”;  name = name + “c”;两条语句总共创建了多少个字符串对象？<br>&#160; &#160; &#160; &#160;创建了两个对象，这两个对象都会放到缓存池中，只是name的引用由”ab”改变为”abc”了。我们在这样用的时候，还需要考虑其他问题，如这个程序会造成内在泄漏，因为缓存池中的在缓存池中的字符串是不会被垃圾回收机制回收的，基本都是常驻内存，所以过多使用String类，可能会出现内存溢出。</p>
<p>（4）字符串比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String s1 = &quot;a&quot;;  </div><div class="line">String s2 = s1 + &quot;b&quot;;  </div><div class="line">String s3 = &quot;ab&quot;;   </div><div class="line">System.out.println(s2 == s3);//false</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;可以看到s2与s3的引用并不相同。由于s2字符串在编译时并不能进行确定，所以首先进入缓存池中的有s1和s3，随后会创建一个新的s2字符串对象，两者当然不一样了。如果程序的字符串连接表达式中没有使用变量或者调用方法，那么该字符串变量的值就能够在编译期间确定下来，并且将该字符换缓存在缓冲区中，同时让该变量指向该字符串；否则将无法利用缓冲区，因为使用了变量和调用了方法之后的字符串变量的值只能在运行期间才能确定连接式的值，也就无法在编译期间确定字符串变量的值，从而无法将字符串变量增加到缓冲区并加以利用。如果要对s1与s2加上final关键字后，结果就为true了。因为会在编译期进行优化处理。所以如果有字符串拼接之类的操作，建议使用StringBuilder类型或StringBuffer类。而StringBuffer在方法加上了同步关键字，多线程情况下使用。</p>
<p>&#160; &#160; &#160; &#160;还可以参考如下博客：</p>
<p><a href="https://my.oschina.net/jiangmitiao/blog/480549" target="_blank" rel="external">String 源码浅析</a>。</p>
<p><a href="http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html" target="_blank" rel="external">String\StringBuffer\StringBuiler比较</a>。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;看JDK的源码是非常有效的学习方法，对深入学习和理解起着关键作用，要保持阅读源码的习惯，之后我们会经常对一些重要的源码进行整理，之前已经看了集合类，今天从基本类型开始，关键是多看，每次看都有新发现，这里主要列出别人整理过的深层次理解，方便自己经常结合源码看。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK源码解析" scheme="http://yoursite.com/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="JDK基础类型源码" scheme="http://yoursite.com/tags/JDK%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>OOM异常实战</title>
    <link href="http://yoursite.com/2017/03/18/OOM%E5%BC%82%E5%B8%B8%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2017/03/18/OOM异常实战/</id>
    <published>2017-03-18T08:27:03.000Z</published>
    <updated>2017-07-28T07:30:49.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOM异常实战"><a href="#OOM异常实战" class="headerlink" title="OOM异常实战"></a>OOM异常实战</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在Java虚拟机除了程序计数器外，其他几个运行时内存区域都可能发生OOM，下面实例一下溢出场景，并分析。</p>
<a id="more"></a>
<h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><h3 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h3><p>有几个重要参数设置如下：</p>
<ol>
<li><p>-Xms  堆大小的最小值设置参数</p>
</li>
<li><p>-Xmx  堆的大小最大值，如果设置为最小值一样，则不允许自动扩展。</p>
</li>
<li><p>-XX：+HeapDumpOnOutOfMemoryError  让内存溢出时Dump出当前内存堆转储快照。</p>
</li>
</ol>
<h3 id="模拟产生方法"><a href="#模拟产生方法" class="headerlink" title="模拟产生方法"></a>模拟产生方法</h3><p>&#160; &#160; &#160; &#160;如果我们不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制回收这些对象，就能模拟抛出OOM异常的情景。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>&#160; &#160; &#160; &#160;<br>使用内存映像分析工具：Eclipse Memory Analyzer对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，即要搞明白是内存泄漏还是内存溢出。 </p>
<ol>
<li>内存泄漏导致的OOM：new出来的很多对象已经不需要了，但仍然有引用指向，所以垃圾回收机制无法回收。 </li>
<li>内存溢出：new出来的对象都是需要的，但堆内存太小装不下了。 </li>
</ol>
<p>&#160; &#160; &#160; &#160;<font color="red">如果是内存泄漏，通过工具查看泄漏对象到GC Roots的引用链。找到泄漏对象是通过怎样的路径与GC Roots发生关联，然后导致垃圾回收机制无法自动回收的。如果不存在内存泄漏，也就是所有的对象都必须存在，这时候就调大堆内存。</font></p>
<h2 id="虚拟机栈和本地方法溢出"><a href="#虚拟机栈和本地方法溢出" class="headerlink" title="虚拟机栈和本地方法溢出"></a>虚拟机栈和本地方法溢出</h2><p>&#160; &#160; &#160; &#160;在hotspot中不区分虚拟机和本地方法栈，因此对于hotspot来说，-Xoss参数存在但是无效，栈容量只由-Xss参数决定。</p>
<p>&#160; &#160; &#160; &#160;书上的实验结果表明；</p>
<ol>
<li>在单个线程下，无论是由于栈帧太大还是虚拟机容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError。</li>
<li>不限于单线程可以模拟出OOM，但是这种产生的内存溢出与栈空间足够大不存在联系，而且越大反而更容易产生内存溢出。原因：<font color="red">内存有限，每个线程分配到的栈容量越大，可以建立的线程数就越少，建立线程的时候就越容易把剩下的内存耗尽。</font></li>
<li>所以在多线程开发中特别注意，StackOverflowError有错误堆栈可以阅读，相对排查简单一些。大多数情况下达到1000～2000完全没有问题，对于正常的递归大多数情况下完全够用了。<font color="red">如果是多线程导致内存溢出的话，就只能减少最大堆或者栈的容量来获得更多的线程。</font></li>
</ol>
<h2 id="常量池溢出"><a href="#常量池溢出" class="headerlink" title="常量池溢出"></a>常量池溢出</h2><h3 id="模拟产生方法-1"><a href="#模拟产生方法-1" class="headerlink" title="模拟产生方法"></a>模拟产生方法</h3><p>&#160; &#160; &#160; &#160;如果要向运行时内存中添加内容，最简单的方式是使用string.intern（）。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;-XX：PermSize        &#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;-XX：MaxPermSize。溢出后提示信息是PermGen space。</p>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><p>&#160; &#160; &#160; &#160;方法区存放class信息，比如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
<h3 id="模拟产生方法-2"><a href="#模拟产生方法-2" class="headerlink" title="模拟产生方法"></a>模拟产生方法</h3><p>&#160; &#160; &#160; &#160;产生许多类区填满方法区，直到溢出。还可以反射和动态代理，还可以用CGLIB直接操作字符码，生成动态类。（框架中精彩需要对类进行增强，都会使用到CGLIB，增强的类越多，就需要越大的方法区保证动态生成的class可以加载入内存）。</p>
<p>&#160; &#160; &#160; &#160;方法区溢出也是常见的内存溢出，一个类如果要被垃圾收集器回收掉条件是十分苛刻的。在动态生成大量Class文件的应用中，需要特别注意类的回收状况。常见的还有JSP应用。</p>
<h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>-XX：MaxDirectMemorySize，如果不指定默认和堆一样大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OOM异常实战&quot;&gt;&lt;a href=&quot;#OOM异常实战&quot; class=&quot;headerlink&quot; title=&quot;OOM异常实战&quot;&gt;&lt;/a&gt;OOM异常实战&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在Java虚拟机除了程序计数器外，其他几个运行时内存区域都可能发生OOM，下面实例一下溢出场景，并分析。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM进阶" scheme="http://yoursite.com/categories/JVM%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="OOM异常" scheme="http://yoursite.com/tags/OOM%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（五）</title>
    <link href="http://yoursite.com/2017/03/12/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/12/高效并发（五）/</id>
    <published>2017-03-12T03:32:52.000Z</published>
    <updated>2017-07-25T07:58:34.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经分析了线程池和同步工具。这里我们来介绍原子类和forkjoin框架。</p>
 <a id="more"></a>
<h2 id="forkjoin框架"><a href="#forkjoin框架" class="headerlink" title="forkjoin框架"></a>forkjoin框架</h2><p>&#160; &#160; &#160; &#160;Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>&#160; &#160; &#160; &#160;我们再通过Fork和Join这两个单词来理解下Fork/Join框架，Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+。。＋10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。Fork/Join的运行流程图如下：</p>
<p><img src="http://cdn3.infoqstatic.com/statics_s2_20170523-0350/resource/articles/fork-join-introduction/zh/resources/21.png" alt=""></p>
<h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>&#160; &#160; &#160; &#160; 工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p>
<p><img src="http://cdn3.infoqstatic.com/statics_s2_20170523-0350/resource/articles/fork-join-introduction/zh/resources/image3.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>&#160; &#160; &#160; &#160;第一步分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</p>
<p>&#160; &#160; &#160; &#160;第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p>
<p>Fork/Join使用两个类来完成以上两件事情：</p>
<p>&#160; &#160; &#160; &#160;ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：</p>
<ol>
<li>RecursiveAction：用于没有返回结果的任务。</li>
<li>RecursiveTask ：用于有返回结果的任务。</li>
</ol>
<p>&#160; &#160; &#160; &#160;ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p>
<p>&#160; &#160; &#160; &#160;使用例子如下,需求是：计算1+2+3+4的结果。：</p>
<p><img src="http://cdn3.infoqstatic.com/statics_s2_20170523-0350/resource/articles/fork-join-introduction/zh/resources/31.png" alt=""></p>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>&#160; &#160; &#160; &#160;源代码中没有volatile或者synchronized这些同步机制也没有锁，其实它的同步是通过硬件指令实现。Integer内部方法不是线程安全的所以并发编程推荐使用AtomicInteger类来替换包装类，但是原子类不是 java.lang.Integer 和相关类的通用替换方法，它们不定义诸如 hashCode 和 compareTo 之类的方法。</p>
<p>&#160; &#160; &#160; &#160;Java提供的原子类是靠 sun 基于 CAS 实现的，CAS 是一种乐观锁。</p>
<p>&#160; &#160; &#160; &#160;原子变量类相当于一种泛化的 volatile 变量，能够支持原子的和有条件的读-改-写操作。AtomicInteger 表示一个int类型的值，并提供了 get 和 set 方法，这些 Volatile 类型的int变量在读取和写入上有着相同的内存语义。它还提供了一个原子的 compareAndSet 方法（如果该方法成功执行，那么将实现与读取/写入一个 volatile 变量相同的内存效果），以及原子的添加、递增和递减等方法。AtomicInteger 表面上非常像一个扩展的 Counter 类，但在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经分析了线程池和同步工具。这里我们来介绍原子类和forkjoin框架。&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="concurrent包总结" scheme="http://yoursite.com/tags/concurrent%E5%8C%85%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（四）</title>
    <link href="http://yoursite.com/2017/03/10/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/10/高效并发（四）/</id>
    <published>2017-03-10T07:01:53.000Z</published>
    <updated>2017-07-24T06:46:53.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经分析了lock和concurrent提供的集合类包括阻塞队列和容器类。这里我们来介绍</p>
 <a id="more"></a>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><p>&#160; &#160; &#160; &#160;线程池作用就是限制系统中执行线程的数量。根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程 排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程 池中有等待的工作线程，就可以开始运行了；否则进入等待队列。</p>
<h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h3><ol>
<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li>
<li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)</li>
</ol>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>&#160; &#160; &#160; &#160;Java里面线程池的顶级接口是Executor，里面就有个execute方法，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。ThreadPoolExecutor是Executors类的底层实现。</p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><h4 id="shutDown"><a href="#shutDown" class="headerlink" title="shutDown()"></a>shutDown()</h4><p>&#160; &#160; &#160; &#160;当线程池调用该方法时,线程池的状态则立刻变成SHUTDOWN状态。此时，则不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException异常。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。</p>
<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><p>&#160; &#160; &#160; &#160;根据JDK文档描述，大致意思是：执行该方法，线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。 </p>
<p>&#160; &#160; &#160; &#160;它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>&#160; &#160; &#160; &#160;包括shubmit，invoke相关和Terminate相关。我们在实现类中在继续分析。</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h4 id="final-AtomicInteger-ctl"><a href="#final-AtomicInteger-ctl" class="headerlink" title="final AtomicInteger ctl"></a>final AtomicInteger ctl</h4><p>&#160; &#160; &#160; &#160;这个变量是整个类的核心，AtomicInteger保证了对这个变量的操作是原子的，通过巧妙的操作，ThreadPoolExecutor用这一个变量保存了两个内容：</p>
<ol>
<li>所有有效线程的数量</li>
<li>各个线程的状态（runState）</li>
</ol>
<p>低29位存线程数，高3位存runState,这样runState有5个值，解释如下：</p>
<pre><code>//线程池正常运行，可以接受新的任务并处理队列中的任务；
private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
//不再接受新的任务，但是会执行队列中的任务；
private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
//不再接受新任务，不处理队列中的任务
private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;

// Packing and unpacking ctl
private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }
private static int workerCountOf(int c)  { return c &amp; CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
</code></pre><h4 id="内部封装了work类"><a href="#内部封装了work类" class="headerlink" title="内部封装了work类"></a>内部封装了work类</h4><p>&#160; &#160; &#160; &#160;内部类Worker是对任务的封装，所有submit的Runnable都被封装成了Worker，它本身也是一个Runnable， 然后利用AQS框架（关于AQS可以看我这篇文章）实现了一个简单的非重入的互斥锁， 实现互斥锁主要目的是为了中断的时候判断线程是在空闲还是运行。</p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>&#160; &#160; &#160; &#160;有4个重要实现类：</p>
<ol>
<li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ol>
<h2 id="同步工具类"><a href="#同步工具类" class="headerlink" title="同步工具类"></a>同步工具类</h2><p>&#160; &#160; &#160; &#160;还有号称四大金刚的同步器。同步工具类可以使任何一种对象，只要该对象可以根据自身的状态来协调控制线程的控制流。阻塞队列可以作为同步工具类，其他类型的同步工具类还包括：信号量（Semaphore）、栅栏（Barrier）以及闭锁（Latch）和交换（exchanger）参考博文：<a href="http://blog.csdn.net/zq602316498/article/details/41779431" target="_blank" rel="external">同步工具类解析</a></p>
<h3 id="CountDownLatch闭锁"><a href="#CountDownLatch闭锁" class="headerlink" title="CountDownLatch闭锁"></a>CountDownLatch闭锁</h3><p>首先我们来介绍闭锁。</p>
<p>&#160; &#160; &#160; &#160;闭锁作用相当于一扇门：在闭锁到达某一状态之前，这扇门一直是关闭的，所有的线程都会在这扇门前等待（阻塞）。只有门打开后，所有的线程才会同时继续运行。<br>闭锁可以用来确保某些活动直到其它活动都完成后才继续执行，例如：</p>
<ol>
<li>确保某个计算在其所有资源都被初始化之后才继续执行。二元闭锁（只有两个状态）可以用来表示“资源R已经被初始化”，而所有需要R操作都必须先在这个闭锁上等待。</li>
<li>确保某个服务在所有其他服务都已经启动之后才启动。这时就需要多个闭锁。让S在每个闭锁上等待，只有所有的闭锁都打开后才会继续运行。<br>3。 等待直到某个操作的参与者（例如，多玩家游戏中的玩家）都就绪再继续执行。在这种情况下，当所有玩家都准备就绪时，闭锁将到达结束状态。</li>
</ol>
<p>&#160; &#160; &#160; &#160;CountDownLatch 是一种灵活的闭锁实现，可以用在上述各种情况中使用。闭锁状态包含一个计数器，初始化为一个正数，表示要等待的事件数量。countDown() 方法会递减计数器，表示等待的事件中发生了一件。await() 方法则阻塞，直到计数器值变为0。</p>
<p>&#160; &#160; &#160; &#160;下面，我们使用闭锁来实现在主线程中计算多个子线程运行时间的功能。具体逻辑是使用两个闭锁，“起始门”用来控制子线程同时运行，“结束门”用来标识子线程是否都结束。</p>
<h3 id="CyclicBarrier和exchanger"><a href="#CyclicBarrier和exchanger" class="headerlink" title="CyclicBarrier和exchanger"></a>CyclicBarrier和exchanger</h3><p>&#160; &#160; &#160; &#160;栅栏（Bariier）类似于闭锁，它能阻塞一组线程知道某个事件发生。栅栏与闭锁的关键区别在于，所有的线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待等待时间，而栅栏用于等待线程。</p>
<p>&#160; &#160; &#160; &#160;CyclicBarrier 可以使一定数量的参与方反复的在栅栏位置汇聚，它在并行迭代算法中非常有用：将一个问题拆成一系列相互独立的子问题。当线程到达栅栏位置时，调用await() 方法，这个方法是阻塞方法，直到所有线程到达了栅栏位置，那么栅栏被打开，此时所有线程被释放，而栅栏将被重置以便下次使用。</p>
<p>&#160; &#160; &#160; &#160;另一种形式的栅栏是Exchanger，它是一种两方（Two-Party）栅栏，各方在栅栏位置上交换数据。例如当一个线程想缓冲区写入数据，而另一个线程从缓冲区中读取数据。这些线程可以使用 Exchanger 来汇合，并将慢的缓冲区与空的缓冲区交换。当两个线程通过 Exchanger 交换对象时，这种交换就把这两个对象安全的发布给另一方。</p>
<p>&#160; &#160; &#160; &#160;Exchanger 可能被视为 SynchronousQueue 的双向形式。我们也可以用两个SynchronousQueue来实现 Exchanger的功能。</p>
<h3 id="信号量Semaphone"><a href="#信号量Semaphone" class="headerlink" title="信号量Semaphone"></a>信号量Semaphone</h3><p>&#160; &#160; &#160; &#160;之前讲的闭锁控制访问的时间，而信号量则用来控制访问某个特定资源的操作数量，控制空间。而且闭锁只能够减少，一次性使用，而信号量则申请可释放，可增可减。 计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p>
<p>&#160; &#160; &#160; &#160;Semaphone 管理这一组许可（permit），可通过构造函数指定。同时提供了阻塞方法acquire，用来获取许可。同时提供了release方法表示释放一个许可。</p>
<p>&#160; &#160; &#160; &#160;Semaphone 可以将任何一种容器变为有界阻塞容器，如用于实现资源池。例如数据库连接池。我们可以构造一个固定长度的连接池，使用阻塞方法 acquire和release获取释放连接，而不是获取不到便失败。（当然，一开始设计时就使用BlockingQueue来保存连接池的资源是一种更简单的方法）。</p>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>　　FutureTask也可以用作闭锁。它表示一种抽象的可生成结果的计算。是通过 Callable 来实现的，相当于一种可生成结果的 Runnable ，并且可处于以下三种状态：等待运行，正在运行，运行完成。当FutureTask进入完成状态后，它会停留在这个状态上。</p>
<p>　　Future.get 用来获取计算结果，如果FutureTask还未运行完成，则会阻塞。FutureTask 将计算结果从执行计算的线程传递到获取这个结果的线程，而FutureTask 的规范确保了这种传递过程能实现结果的安全发布。</p>
<p>　　FutureTask在Executor框架中表示异步任务，还可以用来表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经分析了lock和concurrent提供的集合类包括阻塞队列和容器类。这里我们来介绍&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="concurrent包总结" scheme="http://yoursite.com/tags/concurrent%E5%8C%85%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（三）</title>
    <link href="http://yoursite.com/2017/03/06/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/06/高效并发（三）/</id>
    <published>2017-03-06T03:01:12.000Z</published>
    <updated>2017-07-23T09:22:06.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;在前面的基础知识之上，我们开始对concurrent包的全面分析。</p>
 <a id="more"></a>
<h2 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h2><p>&#160; &#160; &#160; &#160;可参考博文：<a href="http://www.importnew.com/24594.html" target="_blank" rel="external">并发集合总结</a>。</p>
<h3 id="Concurrent-Colleciton相关"><a href="#Concurrent-Colleciton相关" class="headerlink" title="Concurrent Colleciton相关"></a>Concurrent Colleciton相关</h3><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>&#160; &#160; &#160; &#160;采用了锁分离技术，它使用了多个锁代替HashTable中的单个锁，其中get方法并没有加锁。它把区间按照并发级别(concurrentLevel)，分成了若干个segment。默认情况下内部按并发级别为16来创建。对于每个segment的容量，默认情况也是16。当然并发级别(concurrentLevel)和每个段(segment)的初始容量都是可以通过构造函数设定的。</p>
<p>参考博文：<a href="http://www.importnew.com/21781.html" target="_blank" rel="external">concurrenthashmap详解</a></p>
<p><img src="http://images.cnitblog.com/blog/587773/201409/062059451104363.jpg" alt=""></p>
<p>&#160; &#160; &#160; &#160;看起来只是把以前HashTable的一个hash bucket创建了16份而已。那还有其他特殊的吗？其中Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。我们就从put，get，remove方法重点去了解。</p>
<p>&#160; &#160; &#160; &#160;get方法：count变量表示segment中存在entry的个数,hashentry数据结构，还有get方法没有加同步监视器。我们来看下如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">V get(Object key, int hash) &#123;</div><div class="line">        if (count != 0) &#123; // read-volatile // ①</div><div class="line">            HashEntry&lt;K,V&gt; e = getFirst(hash); </div><div class="line">            while (e != null) &#123;</div><div class="line">                if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</div><div class="line">                    V v = e.value;</div><div class="line">                    if (v != null)  // ② 注意这里，结合双层检测锁DCL</div><div class="line">                        return v;</div><div class="line">                    return readValueUnderLock(e); // recheck</div><div class="line">                &#125;</div><div class="line">                e = e.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">transient volatile int count;</div><div class="line"></div><div class="line"></div><div class="line">static final class HashEntry&lt;K,V&gt; &#123;</div><div class="line">    final K key;</div><div class="line">    final int hash;</div><div class="line">    volatile V value;</div><div class="line">    final HashEntry&lt;K,V&gt; next;</div><div class="line">    。。。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;count和value使用了volatile来修改。我们前文说过，Java5之后，JMM实现了对volatile的保证：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。所以，每次判断count变量的时候，即使恰好其他线程改变了segment也会体现出来。</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>&#160; &#160; &#160; &#160;CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>我们要注意以下两点：</p>
<ol>
<li><p>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</p>
</li>
<li><p>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</p>
</li>
</ol>
<p>缺点：</p>
<p>&#160; &#160; &#160; &#160;一、内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>
<p>&#160; &#160; &#160; &#160;针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<p>&#160; &#160; &#160; &#160;二、数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p>参考博文：<a href="http://www.importnew.com/22470.html" target="_blank" rel="external">copyonwriteArrayList解析</a></p>
<h4 id="ConcurrentSkipListmap"><a href="#ConcurrentSkipListmap" class="headerlink" title="ConcurrentSkipListmap"></a>ConcurrentSkipListmap</h4><p>&#160; &#160; &#160; &#160;跳跃表其实也是一种通过“空间来换取时间”的一个算法，通过在每个节点中增加了向前的指针，从而提升查找的效率。跳跃表使用概率均衡技术而不是使用强制性均衡技术，因此，对于插入和删除结点比传统上的平衡树算法更为简洁高效。 跳表是一种随机化的数据结构，目前开源软件 Redis 和 LevelDB 都有用到它。</p>
<p><img src="http://img.blog.csdn.net/20160820163336489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>参考博文：<a href="http://blog.csdn.net/sunxianghuang/article/details/52221913" target="_blank" rel="external">concurrentskipListmap解析</a></p>
<h3 id="Queue接口相关"><a href="#Queue接口相关" class="headerlink" title="Queue接口相关"></a>Queue接口相关</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>&#160; &#160; &#160; &#160;在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现 。</p>
<p>&#160; &#160; &#160; &#160;ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现。参考博文：<a href="http://ifeve.com/concurrentlinkedqueue/" target="_blank" rel="external">ConcurrentLinkedQueue解析</a>。</p>
<p>&#160; &#160; &#160; &#160;ConcurrentLinkedQueue由head节点和tair节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tair节点等于head节点。</p>
<pre><code>private transient volatile Node&lt;e&gt; tail = head;
</code></pre><p><img src="http://ifeve.com/wp-content/uploads/2013/01/ConcurrentLinekedQueue队列入队结构变化图.jpg" alt=""></p>
<p>&#160; &#160; &#160; &#160;我们主要来看入队和出队操作，如上图是入队操作，发现入队主要做两件事情，第一是将入队节点设置成当前队列尾节点的下一个节点。第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点。这时单线程的方式，而多线程是采用CAS方式来实现：</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>&#160; &#160; &#160; &#160;参考博文：<a href="http://blog.csdn.net/suifeng3051/article/details/48807423" target="_blank" rel="external">BlockingQueue解析</a>。BlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种：</p>
<ol>
<li>当队列满了的时候进行入队列操作</li>
<li>当队列空了的时候进行出队列操作</li>
</ol>
<p>阻塞队列主要用在生产者/消费者的场景:</p>
<p><img src="http://img.blog.csdn.net/20150929153140497" alt=""></p>
<p>&#160; &#160; &#160; &#160;负责生产的线程不断的制造新对象并插入到阻塞队列中，直到达到这个队列的上限值。队列达到上限值之后生产线程将会被阻塞，直到消费的线程对这个队列进行消费。同理，负责消费的线程不断的从队列中消费对象，直到这个队列为空，当队列为空时，消费线程将会被阻塞，除非队列中有新的对象被插入。</p>
<p>在Java6中，BlockingQueue的实现类主要有以下几种：</p>
<ol>
<li>ArrayBlockingQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ol>
<h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>&#160; &#160; &#160; &#160; ArrayBlockingQueue:一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。ArrayBlockingQueue是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BlockingQueue queue = new ArrayBlockingQueue(1024);</div><div class="line">queue.put(&quot;1&quot;);</div><div class="line">Object object = queue.take();</div></pre></td></tr></table></figure>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p>&#160; &#160; &#160; &#160;DelayQueue阻塞的是其内部元素，DelayQueue中的元素必须实现 java.util.concurrent.Delayed接口，这个接口的定义非常简单：</p>
<pre><code>public interface Delayed extends Comparable&lt;Delayed&gt; {
long getDelay(TimeUnit unit);
}
</code></pre><p>&#160; &#160; &#160; &#160;getDelay()方法的返回值就是队列元素被释放前的保持时间，如果返回0或者一个负值，就意味着该元素已经到期需要被释放，此时DelayedQueue会通过其take()方法释放此对象。从上面Delayed 接口定义可以看到，它还继承了Comparable接口，这是因为DelayedQueue中的元素需要进行排序，一般情况，我们都是按元素过期时间的优先级进行排序。其实DelayQueue应用场景很多，比如定时关闭连接、缓存对象，超时处理等各种场景。</p>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>LinkedBlockingQueue阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为Integer.MAX_VALUE的容量 。它的内部实现是一个链表。和ArrayBlockingQueue一样，LinkedBlockingQueue 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。下面是一个初始化和使用LinkedBlockingQueue的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BlockingQueue&lt;String&gt; unbounded = new LinkedBlockingQueue&lt;String&gt;();</div><div class="line">BlockingQueue&lt;String&gt; bounded   = new LinkedBlockingQueue&lt;String&gt;(1024);</div><div class="line">bounded.put(&quot;Value&quot;);</div><div class="line">String value = bounded.take();</div></pre></td></tr></table></figure>
<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><p>&#160; &#160; &#160; &#160;一个没有边界的队列，它的排序规则和 java.util.PriorityQueue一样。需要注意，PriorityBlockingQueue中允许插入null对象。所有插入PriorityBlockingQueue的对象必须实现 java.lang.Comparable接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。另外，我们可以从PriorityBlockingQueue获得一个迭代器Iterator，但这个迭代器并不保证按照优先级顺序进行迭代。</p>
<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p>&#160; &#160; &#160; &#160;队列内部仅允许容纳一个元素。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</p>
<h2 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h2><p>&#160; &#160; &#160; &#160;这里首先我们需要总结的是我们应该聪明的使用锁，在jvm的学习中我们已经知道了一些锁优化机制，一些锁的类型，那就是我们在使用的时候应该注意些什么。</p>
<p>这里有一些博文可以参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-lock/" target="_blank" rel="external">如何聪明地使用锁</a>。竞争锁是造成多线程应用程序性能瓶颈的主要原因，在保证程序正确性的前提下，解决同步带来的性能损失的第一步不是去除锁，而是降低锁的竞争。通常，有以下三类方法可以降低锁的竞争：减少持有锁的时间，降低请求锁的频率，或者用其他协调机制取代独占锁。</p>
<h3 id="ReentranLock"><a href="#ReentranLock" class="headerlink" title="ReentranLock"></a>ReentranLock</h3><p>&#160; &#160; &#160; &#160;ReentrantLock是可重入锁，什么是可重入锁呢？可重入锁就是当前持有该锁的线程能够多次获取该锁，无需等待。可重入锁是如何实现的呢？这要从ReentrantLock的一个内部类Sync的父类说起，Sync的父类是AbstractQueuedSynchronizer（后面简称AQS）。Sync被设计成为安全的外部不可访问的内部类。参考博文：<a href="http://www.importnew.com/24006.html" target="_blank" rel="external">ReentranLock解析</a>，<a href="http://www.codeceo.com/article/reentrantlock-learn.html" target="_blank" rel="external">ReentranLock解析2</a>.</p>
<p><img src="http://static.codeceo.com/images/2016/08/reentrantlock01.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;这里我们首先来说一下AQS。AQS是JDK1.5提供的一个基于FIFO等待队列实现的一个用于实现同步器的基础框架，这个基础框架的重要性可以这么说，JCU包里面几乎所有的有关锁、多线程并发以及线程同步器等重要组件的实现都是基于AQS这个框架。参考博文：<a href="http://www.importnew.com/22924.html" target="_blank" rel="external">深度解析AQS</a>。<a href="http://www.importnew.com/22102.html" target="_blank" rel="external">AQS实现分析（上）</a>,<a href="http://www.importnew.com/22108.html" target="_blank" rel="external">AQS实现分析（下）</a></p>
<p>&#160; &#160; &#160; &#160;<font color="red">AQS的核心思想是基于volatile int state这样的一个属性同时配合Unsafe工具对其原子性的操作来实现对当前锁的状态进行修改。当state的值为0的时候，标识改Lock不被任何线程所占有。</font>我们假设目前有三个线程Thread1、Thread2、Thread3同时去竞争锁，如果结果是Thread1获取了锁，Thread2和Thread3进入了等待队列，那么他们的样子如下：</p>
<p><img src="http://static.oschina.net/uploads/space/2016/0403/104016_XiVq_1759553.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;AQS的等待队列基于一个双向链表实现的，HEAD节点不关联线程，后面两个节点分别关联Thread2和Thread3，他们将会按照先后顺序被串联在这个队列上。这个时候如果后面再有线程进来的话将会被当做队列的TAIL。</p>
<p>&#160; &#160; &#160; &#160;三个线程同时进来，他们会首先会通过CAS去修改state的状态，如果修改成功，那么竞争成功，因此这个时候三个线程只有一个CAS成功，其他两个线程失败，也就是tryAcquire返回false。addWaiter会把将当前线程关联的EXCLUSIVE类型的节点入队列，如果队尾节点不为null，则说明队列中已经有线程在等待了，那么直接入队尾。对于我们举的例子，这边的逻辑应该是走enq，也就是开始队尾是null，其实这个时候整个队列都是null的。</p>
<p>&#160; &#160; &#160; &#160;<font color="red">他们是如何实现不进行加锁，当有多个线程，或者说很多很多的线程同时执行的时候，怎么能保证最终他们都能够乖乖的入队列而不会出现并发问题的呢？这也是这部分代码的经典之处，多线程竞争，热点、单点在队列尾部，多个线程都通过【CAS+死循环】这个free-lock黄金搭档来对队列进行修改，每次能够保证只有一个成功，如果失败下次重试，如果是N个线程，那么每个线程最多loop N次，最终都能够成功。</font></p>
<p>&#160; &#160; &#160; &#160;羊群效应：</p>
<p>&#160; &#160; &#160; &#160;这里说一下羊群效应，当有多个线程去竞争同一个锁的时候，假设锁被某个线程占用，那么如果有成千上万个线程在等待锁，有一种做法是同时唤醒这成千上万个线程去去竞争锁，这个时候就发生了羊群效应，海量的竞争必然造成资源的剧增和浪费，因此终究只能有一个线程竞争成功，其他线程还是要老老实实的回去等待。<font color="red">AQS的FIFO的等待队列给解决在锁竞争方面的羊群效应问题提供了一个思路：保持一个FIFO队列，队列每个节点只关心其前一个节点的状态，线程唤醒也只唤醒队头等待线程。其实这个思路已经被应用到了分布式锁的实践中，</font>见：Zookeeper分布式锁的改进实现方案。</p>
<h3 id="ReetrantReadWriteLock"><a href="#ReetrantReadWriteLock" class="headerlink" title="ReetrantReadWriteLock"></a>ReetrantReadWriteLock</h3><p>&#160; &#160; &#160; &#160;ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。 所有读写锁的实现必须确保写操作对读操作的内存影响。换句话说，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。 读写锁比互斥锁允许对于共享数据更大程度的并发。每次只能有一个写线程，但是同时可以有多个线程并发地读数据。ReadWriteLock适用于读多写少的并发情况。ReadWriteLock是一个接口，主要有两个方法，如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public interface ReadWriteLock &#123;</div><div class="line">    /**</div><div class="line">     * 返回读锁</div><div class="line">     */</div><div class="line">    Lock readLock();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 返回写锁</div><div class="line">     */</div><div class="line">    Lock writeLock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考博文：<a href="http://blog.csdn.net/qq_19431333/article/details/70568478" target="_blank" rel="external">ReetrantReadWriteLock解析</a>，</p>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>&#160; &#160; &#160; &#160;Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set （wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。</p>
<p>&#160; &#160; &#160; &#160;在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class BoundedBuffer &#123;  </div><div class="line">   final Lock lock = new ReentrantLock();//锁对象  </div><div class="line">   final Condition notFull  = lock.newCondition();//写线程条件   </div><div class="line">   final Condition notEmpty = lock.newCondition();//读线程条件   </div><div class="line">  </div><div class="line">   final Object[] items = new Object[100];//缓存队列  </div><div class="line">   int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/;  </div><div class="line">  </div><div class="line">   public void put(Object x) throws InterruptedException &#123;  </div><div class="line">     lock.lock();  </div><div class="line">     try &#123;  </div><div class="line">       while (count == items.length)//如果队列满了   </div><div class="line">         notFull.await();//阻塞写线程  </div><div class="line">       items[putptr] = x;//赋值   </div><div class="line">       if (++putptr == items.length) putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0  </div><div class="line">       ++count;//个数++  </div><div class="line">       notEmpty.signal();//唤醒读线程  </div><div class="line">     &#125; finally &#123;  </div><div class="line">       lock.unlock();  </div><div class="line">     &#125;  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">   public Object take() throws InterruptedException &#123;  </div><div class="line">     lock.lock();  </div><div class="line">     try &#123;  </div><div class="line">       while (count == 0)//如果队列为空  </div><div class="line">         notEmpty.await();//阻塞读线程  </div><div class="line">       Object x = items[takeptr];//取值   </div><div class="line">       if (++takeptr == items.length) takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0  </div><div class="line">       --count;//个数--  </div><div class="line">       notFull.signal();//唤醒写线程  </div><div class="line">       return x;  </div><div class="line">     &#125; finally &#123;  </div><div class="line">       lock.unlock();  </div><div class="line">     &#125;  </div><div class="line">   &#125;   </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，这也是ArrayBlockingQueue的内部实现。下面分析一下代码的执行过程：</p>
<ol>
<li><p>一个写线程执行，调用put方法；</p>
</li>
<li><p>判断count是否为100，显然没有100；</p>
</li>
<li><p>继续执行，存入值；</p>
</li>
<li><p>判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1；</p>
</li>
<li><p>仅唤醒读线程阻塞队列中的一个；</p>
</li>
<li><p>一个读线程执行，调用take方法；</p>
</li>
<li><p>……</p>
</li>
<li><p>仅唤醒写线程阻塞队列中的一个。</p>
</li>
</ol>
<p>　　这就是多个Condition的强大之处，假设缓存队列中已经存满，那么阻塞的肯定是写线程，唤醒的肯定是读线程，相反，阻塞的肯定是读线程，唤醒的肯定是写线程，那么假设只有一个Condition会有什么效果呢，缓存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。</p>
<p>参考博文：<a href="http://blog.csdn.net/luonanqin/article/details/41894755" target="_blank" rel="external">Condition的await-signal流程详解</a>,<a href="http://blog.csdn.net/ghsau/article/details/7481142" target="_blank" rel="external">Condition-线程通信更高效的方式</a>,<a href="http://www.importnew.com/9281.html" target="_blank" rel="external">怎么理解Condition</a>.</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>　　文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;在前面的基础知识之上，我们开始对concurrent包的全面分析。&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="concurrent包总结" scheme="http://yoursite.com/tags/concurrent%E5%8C%85%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（二）</title>
    <link href="http://yoursite.com/2017/03/03/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/03/高效并发（二）/</id>
    <published>2017-03-03T07:31:12.000Z</published>
    <updated>2017-07-23T09:17:52.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　在学习完虚拟机之后，我们了解了java的内存模型、实现线程安全的方法和jvm的一些锁优化机制，我们现在就把方向在往线程的基本操作，到concurrent包里面的线程安全类、原子类和一些lock的实现类。了解整个java并发基础。</p>
 <a id="more"></a>
<h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><h3 id="产生线程的方法"><a href="#产生线程的方法" class="headerlink" title="产生线程的方法"></a>产生线程的方法</h3><ol>
<li>继承thread，重写run方法</li>
<li>thread+runnable</li>
<li>callable+future（新型）</li>
</ol>
<h3 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h3><ol>
<li>join</li>
<li>sleep</li>
<li>yield</li>
<li>修改优先级</li>
</ol>
<h3 id="传统线程里面的通信"><a href="#传统线程里面的通信" class="headerlink" title="传统线程里面的通信"></a>传统线程里面的通信</h3><ol>
<li>notify</li>
<li>notifyAll</li>
<li>wait</li>
</ol>
<h2 id="并发必要知识"><a href="#并发必要知识" class="headerlink" title="并发必要知识"></a>并发必要知识</h2><p>　　由第一节我们知道了jvm的内存模型的特点：原子性、可见性、有序性。其中多个过程之间内存可见性的顺序可能不一致，比如下面的程序例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class Test1 &#123;</div><div class="line">    private int a=1, b=2;</div><div class="line"> </div><div class="line">    public void foo()&#123;  // 线程1 </div><div class="line">        a=3;</div><div class="line">        b=4;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public int getA()&#123; // 线程2</div><div class="line">        return a;</div><div class="line">    &#125;    </div><div class="line">    public int getB()&#123; // 线程2</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//可能出现的结果</div><div class="line"></div><div class="line">A：a=1, b=2  // 都未改变</div><div class="line">B：a=3, b=4  // 都改变了</div><div class="line">C：a=3, b=2  //  a改变了，b未改变</div><div class="line">D：a=1, b=4  //  b改变了，a未改变</div></pre></td></tr></table></figure>
<p>造成这个的原因有下面两个：</p>
<font color="red"><br><br>1. Java编译器的重排序(Reording)操作有可能导致执行顺序和代码顺序不一致<br><br><br>2. 从线程工作内存写回主存时顺序无法保证。<br><br><br></font><br>　　正因为上面的那些问题，JMM中一个重要问题就是：如何让多线程之间，对象的状态对于各线程的“可视性”是顺序一致的。它的解决方式就是 Happens-before 规则：<br>JMM为所有程序内部动作定义了一个偏序关系，叫做happens-before。要想保证执行动作B的线程看到动作A的结果（无论A和B是否发生在同一个线程中），A和B之间就必须满足happens-before关系。<br><br><img src="http://opb7t58xj.bkt.clouddn.com/happen-before.png" alt=""><br><br>　　<font color="red">我们重点关注的是②，③，这两条也是我们通常编程中常用的。也就是加锁（包括新的lock类和synchronized）和volatile（语义增强了），当然也有不变类（final）和atomic原子类。</font>

<h3 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h3><p>　　早期Java中的锁只有最基本的synchronized，它是一种互斥的实现方式。在Java5之后，增加了一些其它锁，比如ReentrantLock，它基本作用和synchronized相似，但提供了更多的操作方式，比如在获取锁时不必像synchronized那样只是傻等，可以设置定时，轮询，或者中断，这些方法使得它在获取多个锁的情况可以避免死锁操作。</p>
<p>　　而我们需要了解的是ReentrantLock的性能相对synchronized来说有很大的提高。（不过据说Java6后对synchronized进行了优化，两者已经接近了。）在ConcurrentHashMap中，每个hash区间使用的锁正是ReentrantLock。</p>
<h3 id="增强的volatile语义"><a href="#增强的volatile语义" class="headerlink" title="增强的volatile语义"></a>增强的volatile语义</h3><p>　　Volatile可以看做一种轻量级的锁，但又和锁有些不同。</p>
<ol>
<li>它对于多线程，不是一种互斥（mutex）关系。</li>
<li>用volatile修饰的变量，不能保证该变量状态的改变对于其他线程来说是一种“原子化操作”。</li>
</ol>
<p>　　在Java5之前，JMM对Volatile的定义是：保证读写volatile都直接发生在main memory中，线程的working memory不进行缓存。它只承诺了读和写过程的可见性，并没有对Reording做限制，所以旧的Volatile并不太可靠。在Java5之后，JMM对volatile的语义进行了增强。就是我们看到的③ volatile变量法则。对volatile域的写入操作先行于每一个后续的读写操作。</p>
<p>　　所以，在使用Volatile时，需要注意：首先，需不需要互斥；其次，对象状态的改变是不是原子化的。它可以简化实现或者同步策略，确保引用对象的可见性，比如标志生命周期的事件：开始或者关闭。</p>
<p>脆弱的使用条件：</p>
<ol>
<li>写入变量不依赖变量的当前值，或者能够保证只有单一的线程修改变量的值。</li>
<li>变量不需要和其他变量共同参与不变约束。</li>
<li>访问变量时不需要其他原因加锁。<h3 id="不变模式（immutable）"><a href="#不变模式（immutable）" class="headerlink" title="不变模式（immutable）"></a>不变模式（immutable）</h3>　　多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。</li>
</ol>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>　　如果操作都是原子操作，那就实现线程安全了。</p>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>　　四种进程或线程同步互斥的控制方法：</p>
<ol>
<li><p>临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 </p>
</li>
<li><p>互斥量:为协调共同对一个共享资源的单独访问而设计的。 </p>
</li>
<li><p>信号量:为控制一个具有有限数量用户资源而设计。 </p>
</li>
<li><p>事件:用来通知线程有一些事件已发生，从而启动后继任务的开始。</p>
</li>
</ol>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>　　文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　在学习完虚拟机之后，我们了解了java的内存模型、实现线程安全的方法和jvm的一些锁优化机制，我们现在就把方向在往线程的基本操作，到concurrent包里面的线程安全类、原子类和一些lock的实现类。了解整个java并发基础。&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发基础知识" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：替换空格</title>
    <link href="http://yoursite.com/2017/03/03/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2017/03/03/算法：替换空格/</id>
    <published>2017-03-03T07:23:15.000Z</published>
    <updated>2017-08-10T11:56:34.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&#160; &#160; &#160; &#160;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
  <a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>　　C／C++中每个字符串都已字符’\0’作为结尾，这样我吗就能很方便的找到字符串的末位，但是这个特点导致字符串都有一个额外的开销。而在Java和C#中，String是不可变的，一旦试图改变，将产生一个新的实例。所以要活用StringBuilder和StringBuffer。可参考这个博文：<a href="http://blog.csdn.net/qh_java/article/details/46382265" target="_blank" rel="external">从源码角度分析Java三种字符串</a>。</p>
<p>&#160; &#160; &#160; &#160;用Java实现本题，输入的是一个StringBuffer，我们可以先定义一个返回字符串StringBuffer类型，遍历一遍字符串，使用charAt（int i）方法，如果当前字符没空字符，则使用append（char c）添加给定字符，如果不是则添加该字符。最后把StringBuffer变成String返回。使用toStirng（）方法。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>public String replaceSpace(StringBuffer str) {
    StringBuilder newstr =new StringBuilder();
    for(int i=0;i&lt;str.length();i++){
        if(str.charAt(i)==&apos; &apos; )
            newstr.append(&quot;%&quot;).append(&quot;2&quot;).append(&quot;0&quot;);
        else
           newstr.append(str.charAt(i));
    }
           return newstr.toString();
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;替换空格&quot;&gt;&lt;a href=&quot;#替换空格&quot; class=&quot;headerlink&quot; title=&quot;替换空格&quot;&gt;&lt;/a&gt;替换空格&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>高效并发（一）</title>
    <link href="http://yoursite.com/2017/03/02/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/02/高效并发（一）/</id>
    <published>2017-03-02T08:33:26.000Z</published>
    <updated>2017-07-21T08:38:34.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;并发处理的广泛应用是使得Amdahl定律代替摩尔定律称为计算机性能发展源动力的根本原因，也是人类压榨计算机能力最有力的武器。</p>
 <a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&#160; &#160; &#160; &#160;多任务处理在现代操作系统中几乎已是一项必备的功能了，许多情况下，让计算机同时去做几件事，只是处理器的运算能力太强大了，与通讯子系统差距太大，大部分时间花了在磁盘i／o，网络通讯和数据库访问。后来在主内存和处理器之间加入了高速缓冲区cache，java的内存模型也是参考那样的方式设计的如下图：</p>
<p><img src="http://img.my.csdn.net/uploads/201302/06/1360141335_1299.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;线程间通信的步骤：首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</p>
<h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><p>&#160; &#160; &#160; &#160;八种操作来完成：来完成一个变量从主内存拷贝到工作内存、以及工作内存同步回主内存之内。</p>
<ol>
<li>Lock（锁定）：作用于主内存的变量，将主内存该变量标记成当前线程私有的，其他线程无法访问。</li>
<li>Unlock（解锁）：作用于主内存的变量，解除主内存中该变量的锁定状态，让他变成线程共享变量。</li>
<li>Read（读取）：作用于主内存的变量，将该变量读取到当前线程的工作内存中，以便进行load操作。</li>
<li>Load（加载）：作用于工作内存中的变量，将read获取到的变量载入工作内存的变量副本中。</li>
<li>Use（使用）：作用于工作内存中的变量，虚拟机执行引擎在执行字节码指令的时候，碰到了一个变量就会执行该操作，使用该变量。</li>
<li>Assgin（赋值）：作用于工作内存中的变量，虚拟机执行引擎在执行字节码指令的时候，碰到了变量赋值的指令就会执行该操作。</li>
<li>Store（存储）：作用于工作内存中的变量，将工作内存中的变量放入主内存，以便进行write操作。</li>
<li>Write（写入）：作用于主内存中的变量，将store得到的变量放入主内存的变量中。</li>
</ol>
<p>&#160; &#160; &#160; &#160;说明：如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序的执行store和write操作。这两个操作必须按顺序执行，但是没有保证是连续执行，也就是说read与load之间、store与write之间是可插入其他指令的。除此之外，Java内存模型还规定了在执行上述八种基本操作时必须满足如下规则：</p>
<ol>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况。</li>
<li>不允许一个线程丢弃它的最近assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，就是对一个变量执行use和store之前必须先执行过了assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，僵尸清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>&#160; &#160; &#160; &#160;它有两个语义：</p>
<ol>
<li>保证该变量对所以线程的可见性，但不是总能保证线程安全性，因为java的操作并非原子操作。</li>
<li>禁止指令重排序。指令重排序会干扰并发程序的执行。</li>
</ol>
<p>&#160; &#160; &#160; &#160;我们如何选择：volatile的效率是高于锁的，只是在写操作上因为防止重排序插入了内存屏障指令高于普通变量。我们重点放到只使用volatile是否就能满足我们的业务需求，而且对double和long类型变量我们一般不会用到，可能会读到半个变量。</p>
<p>&#160; &#160; &#160; &#160;Java内存模型中对volatile变量定义的特殊规则：</p>
<ol>
<li>在工作内存中，每次使用volatile变量前都必须从主内存中刷新最新的值，用于保证能看到其他线程对变量V所做的修改后的值。</li>
<li>在工作内存中，每次修改后的值都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量的修改。</li>
<li>volatile修饰的变量不会被指令重排优化，保证代码的执行顺序与程序的顺序相同。</li>
</ol>
<h2 id="内存模型的特点"><a href="#内存模型的特点" class="headerlink" title="内存模型的特点"></a>内存模型的特点</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>&#160; &#160; &#160; &#160;由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们可以大致的认为基本数据类型的访问读写是具备原子性的（long和double除外）。Java代码中的同步块即synchronized关键字，因此在synchronized块之间的操作也具备原子性。内部是通过字节码指令monitorenter和monitorexit来实现。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>&#160; &#160; &#160; &#160;就是当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值。关键字synchronized和final也能保证可见性。首先同步块是因为对变量执行unlock操作之前，必须先把次变量同步回主内存中。而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this指针传递出去，那么在其他线程中就能看见final字段的值。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>&#160; &#160; &#160; &#160;用synchronized和volatile关键字来保证线程操作之间的有序性。volatile本省就包含禁止指令重排序的语义，而synchronized则是因为：一个变量在同一时刻只允许一条线程对齐进行lock操作。这个规则决定了持有同一个锁的两个同步块只能串行的进入。</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>　　如果Java内存模型中所有的有序性都只靠volatile和synchronized来完成，那么有一些操作将会变得很啰嗦。java内存模型中的一个重点原则——先行发生原则（Happens-Before），使用这个原则作为依据，来指导你判断是否存在线程安全和竞争问题。</p>
<ol>
<li>程序顺序规则：在程序中，如果A操作在B操作之前（比如A代码在B代码上面，或者由A程序调用B程序），那么在这个线程中，A操作将在B操作之前执行。</li>
<li>管理锁定规则：一个unlock操作先于后面对同一个锁的lock操作之前执行。<br>volatile变量规则：对一个volatile变量的写操作必须在对该变量的读操作之前发生。</li>
<li>线程启动规则：线程的Thread.start()必须在该线程所有其他操作之前发生。</li>
<li>线程终止规则：线程中所有操作都先行发生于该线程的终止检测。可以通过Thread.join()方法结束、Thread.isAlive()的返回值判断线程是否终止。</li>
<li>线程中断规则：对线程interrupt()方法的调用必须在被中断线程的代码检测到interrupt调用之前执行。</li>
<li>对象终结规则：对象的初始化（构造函数的调用）必须在该对象的finalize()方法完成。<br>传递性：如果A先行发生于B，B先行发生于C，那么A先行发生于C。</li>
</ol>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>　　主要有三种方式：使用内核线程KLT、用户线程UT、使用用户和轻量级进程LWP混合。操作系统支持怎么样的线程模型，很大程度决定了java采用何种线程实现方式，对于java程序的编码和运行来说是差异是透明的。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>　　分为协同式和抢占式两种。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>　　分为以下几种：新建、运行、无限期等待、限期等待、阻塞、结束</p>
<p><img src="http://img.blog.csdn.net/20160717080817309" alt=""></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>　　文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;并发处理的广泛应用是使得Amdahl定律代替摩尔定律称为计算机性能发展源动力的根本原因，也是人类压榨计算机能力最有力的武器。&lt;/p&gt;
    
    </summary>
    
      <category term="高效并发" scheme="http://yoursite.com/categories/%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java内存模型" scheme="http://yoursite.com/tags/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记整理（五）</title>
    <link href="http://yoursite.com/2017/02/18/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/18/MySQL学习笔记整理（五）/</id>
    <published>2017-02-18T01:23:11.000Z</published>
    <updated>2017-07-18T06:03:53.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;这篇我们从sql语句优化开始分析，这个时最基础的，可能我们在使用过程中都没有注意，也没有相关经验，但是有了这个意识，我们需要看别人总结的经验，自己去记忆和动手试下实例，加深理解。然后从mysql引擎的选择等方面进行分析，更恰当的去使用mysql。</p>
  <a id="more"></a>
<h2 id="sql语句的技巧"><a href="#sql语句的技巧" class="headerlink" title="sql语句的技巧"></a>sql语句的技巧</h2><h3 id="group-by和having"><a href="#group-by和having" class="headerlink" title="group by和having"></a>group by和having</h3><p>&#160; &#160; &#160; &#160;在使用group by 分组查询是，默认分组后，还会排序，可能会降低速度.例子如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/group1.png" alt=""></p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/group1.png" alt=""><br>&#160; &#160; &#160; &#160;<font color="red">在group by 后面增加 order by null 就可以防止排序.</font></p>
<p>tips：mysql中group by having 用法需要注意的事项: </p>
<ol>
<li><p>GROUP BY：<br>group by 有一个原则,就是 select 后面的所有列中,没有使用聚合函数的列,必须出现在 group by后面。<br>比如 select name,sum(point) from table_name<br>这样sql语句会报错，必须写成:<br>select name,sum(point) from table_name GROUP BY name </p>
</li>
<li><p>HAVING<br>把 HAVING 加入 SQL 的原因是，WHERE 无法应用于合计函数，而如果没有 HAVING，就无法测试结果条件。<br>select name,sum(point)<br>from table_name GROUP BY name<br>HAVING sum(point)&gt;1000 </p>
</li>
<li><p>having通常和group by联合使用.</p>
</li>
</ol>
<p>参考连接：<a href="http://blog.csdn.net/bingogirl/article/details/52559302" target="_blank" rel="external">GROUP BY和HAVING</a></p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>&#160; &#160; &#160; &#160;有些情况下，可以使用连接来替代子查询。因为使用join，MySQL不需要在内存中创建临时表。</p>
<pre><code>select * from dept, emp where dept.deptno=emp.deptno; //简单处理方式

select * from dept left join emp on dept.deptno=emp.deptno; //左外连接，效果更佳！
</code></pre><p>参考这篇博客：<a href="http://www.cnblogs.com/BeginMan/p/3754322.html" target="_blank" rel="external">mysql三种连接查询总结和性能分析</a></p>
<h3 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h3><p> 参考这篇博文：<a href="http://www.cnblogs.com/glory-jzx/archive/2012/07/19/2599215.html" target="_blank" rel="external">exists用法</a></p>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>这里放几个别人整理好的sql优化，从细节上我们要把握。</p>
<ol>
<li><a href="http://www.cnblogs.com/ATree/archive/2011/02/13/sql_optimize_1.html" target="_blank" rel="external">优化sql查询</a>。</li>
</ol>
<ol>
<li><a href="http://www.jb51.net/article/39221.htm" target="_blank" rel="external">sql优化常用的30的技巧</a>。</li>
</ol>
<h2 id="选择合适的存储引擎"><a href="#选择合适的存储引擎" class="headerlink" title="选择合适的存储引擎"></a>选择合适的存储引擎</h2><ol>
<li><p>myisam 存储: 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. ,比如 bbs 中的 发帖表，回复表。（要定期碎片整理，因为删除了数据，MYD文件不会变小，整理可用optimize table XXX）。</p>
</li>
<li><p>INNODB 存储: 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表.</p>
</li>
</ol>
<ol>
<li>Memory 存储，比如我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用memory, 速度极快. 重启mysql就没有了。。。没有持久化机制，不像redis。</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>&#160; &#160; &#160; &#160;下面从几个方面来比较几个存储引擎。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt=""></p>
<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p>&#160; &#160; &#160; &#160;<a href="http://www.cnblogs.com/100thMountain/p/4692008.html" target="_blank" rel="external">mysql字段类型选择</a></p>
<h2 id="分表分区"><a href="#分表分区" class="headerlink" title="分表分区"></a>分表分区</h2><p>&#160; &#160; &#160; &#160;分水平分表和垂直分表。5.1版本之后才用分区。</p>
<p>&#160; &#160; &#160; &#160;<a href="http://www.2cto.com/database/201503/380348.html" target="_blank" rel="external">mysql分表分区详解</a></p>
<h2 id="读写分离、负载均衡、主从复制"><a href="#读写分离、负载均衡、主从复制" class="headerlink" title="读写分离、负载均衡、主从复制"></a>读写分离、负载均衡、主从复制</h2><p>&#160; &#160; &#160; &#160;这些我们在以后分布式系统构建中在深入学习。</p>
<p><img src="http://images2015.cnblogs.com/blog/47685/201606/47685-20160605035114867-448644269.jpg" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;这里我们就分项的讲诉了许多的优化策略和原理方法，当然并不是全部。要记住这些方法，随时使用。可以参考这篇博文：<a href="http://blog.csdn.net/zls986992484/article/details/52860496" target="_blank" rel="external">mysql优化详解</a></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;这篇我们从sql语句优化开始分析，这个时最基础的，可能我们在使用过程中都没有注意，也没有相关经验，但是有了这个意识，我们需要看别人总结的经验，自己去记忆和动手试下实例，加深理解。然后从mysql引擎的选择等方面进行分析，更恰当的去使用mysql。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql学习" scheme="http://yoursite.com/categories/mysql%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记整理（四）</title>
    <link href="http://yoursite.com/2017/02/16/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/16/MySQL学习笔记整理（四）/</id>
    <published>2017-02-16T04:12:13.000Z</published>
    <updated>2017-07-16T07:04:46.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经讲了怎么去建立索引，对索引的基本操作，这篇讲如果去适当的使用索引。我们先了解索引的优缺点，然后在这个基础上分析使用索引的恰当时机。</p>
  <a id="more"></a>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>&#160; &#160; &#160; &#160;创建索引可以大大提高系统的性能。</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 </li>
</ol>
<p>&#160; &#160; &#160; &#160;也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<h2 id="适合建立索引的情况"><a href="#适合建立索引的情况" class="headerlink" title="适合建立索引的情况"></a>适合建立索引的情况</h2><p>一般来说，应该在这些列上创建索引：</p>
<ol>
<li>在经常需要搜索的列上，可以加快搜索的速度；</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
</ol>
<h2 id="不适合建立索引的情况"><a href="#不适合建立索引的情况" class="headerlink" title="不适合建立索引的情况"></a>不适合建立索引的情况</h2><p>一般来说，不应该创建索引的的这些列具有下列特点：</p>
<ol>
<li>对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>
<li>对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>
<li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>
</ol>
<p><a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="external">此处为参考链接</a>。</p>
<h2 id="索引的使用分析"><a href="#索引的使用分析" class="headerlink" title="索引的使用分析"></a>索引的使用分析</h2><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>&#160; &#160; &#160; &#160;下图说明利用这个指令出现的每项及其含义：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/explain.png" alt=""></p>
<h3 id="使用索引的几个注意事项"><a href="#使用索引的几个注意事项" class="headerlink" title="使用索引的几个注意事项"></a>使用索引的几个注意事项</h3><p>&#160; &#160; &#160; &#160;我们把dept这张表的deptno列设为主键，然后在把dname和loc列设为复合索引。代码如下：</p>
<pre><code>//添加主键
alter table dept add primary key(deptno);
//  dname 左边的列,loc就是右边的列
alter table dept add index my_ind (dname,loc); 
</code></pre><ol>
<li>说明，如果我们的表中有复合索引(索引作用在多列上)， 此时我们注意:对于创建的多列索引，只要查询条件使用了最左边的列，索引一般就会被使用。<pre><code>explain select * from dept where loc=&apos;aaa&apos;\G；//此处就不会使用到索引
</code></pre></li>
</ol>
<ol>
<li><p>对于使用like的查询，查询如果是  ‘%aaa’ 不会使用到索引,‘aaa%’ 会使用到索引。</p>
<p> explain select * from dept where dname like ‘%aaa’\G</p>
<p> 不能使用索引，即，在like查询时，关键的 ‘关键字’ , 最前面，不能使用 % 或者 _这样的字符.， 如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p>
</li>
<li><p>如果条件中有or，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引, 我们建议大家尽量避免使用or 关键字</p>
<p>select * from dept where dname=’xxx’ or loc=’xx’</p>
<p>select * from dept where dname=’xxx’ or loc=’xx’ or deptno=45</p>
<p>这两个语句执行比较就可以等到结果。</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。(添加时,字符串必须’’), 也就是，如果列是字符串类型，就一定要用 ‘’ 把他包括起来.</p>
</li>
<li><p>如果mysql估计使用全表扫描要比使用索引快，则不使用索引。情况特殊，比如空表或者记录只有一条的时候。</p>
</li>
</ol>
<h3 id="查询索引使用情况"><a href="#查询索引使用情况" class="headerlink" title="查询索引使用情况"></a>查询索引使用情况</h3><p>&#160; &#160; &#160; &#160;如何查看索引使用的情况，就像看缓存命中率一样:</p>
<pre><code>show status like ‘Handler_read%’;
</code></pre><p>tips：</p>
<pre><code>handler_read_key:这个值越高越好，越高表示使用索引查询到的次数。

handler_read_rnd_next:这个值越高，说明查询低效。
</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经讲了怎么去建立索引，对索引的基本操作，这篇讲如果去适当的使用索引。我们先了解索引的优缺点，然后在这个基础上分析使用索引的恰当时机。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql学习" scheme="http://yoursite.com/categories/mysql%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记整理（三）</title>
    <link href="http://yoursite.com/2017/02/15/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/15/MySQL学习笔记整理（三）/</id>
    <published>2017-02-15T05:02:11.000Z</published>
    <updated>2017-07-15T03:55:10.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;上篇已经建立了测试数据库，然后通过相关工具找到了慢查询的语句，这些就是我们优化的对象，本篇就从索引的角度去改善我们的数据库性能。共四种索引，主键索引、唯一索引、普通索引、全文索引。索引是有消耗的，占空间的，MYI格式文件在data文件夹下。<br>  <a id="more"></a></p>
<p>&#160; &#160; &#160; &#160;<font color="red">索引能使查询变快的原理</font>：先建了一个索引文件，就是MYI文件，然后建立查找二叉树（也叫B树，二叉搜索树，二叉排序树）。利用了二叉树算法，使搜索性能逼近二分查找，但是他比连续内存空间的二分查找优点是，插入和删除不需要移动大量数据，通常是常数开销。记录下了对应索引数值的物理位置，所以数据库换了路径，索引也失效了。</p>
<p>&#160; &#160; &#160; &#160;学会用并利用explain来分析语句。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86.png" alt=""></p>
<h2 id="建立适当的索引"><a href="#建立适当的索引" class="headerlink" title="建立适当的索引"></a>建立适当的索引</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>&#160; &#160; &#160; &#160;当一张表，把某个列设为主键的时候，则该列就是主键索引。主键不能为null且不允许重复。</p>
<pre><code>create table aaa
(id int unsigned primary key auto_increment ,
name varchar(32) not null defaul ‘’);
</code></pre><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>&#160; &#160; &#160; &#160;这是id 列就是主键索引。</p>
<p>&#160; &#160; &#160; &#160;如果你创建表时，没有指定主键索引，也可以在创建表后，在添加指令:</p>
<pre><code>alter table 表名 add primary key (列名);
</code></pre><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>&#160; &#160; &#160; &#160;举例:</p>
<pre><code>create table bbb (id int , name varchar(32) not null default ‘’);

alter table bbb add primary key (id);
</code></pre><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>&#160; &#160; &#160; &#160;添加之后发现库文件MYI文件变大。我们在我们测试样本的emp库建立主键索引，且前后查询对比如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; select * from emp where empno=3456789;</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| empno   | ename  | job      | mgr | hiredate   | sal     | comm   | deptno |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| 3456789 | mFmwwU | SALESMAN |   1 | 2017-05-05 | 2000.00 | 400.00 |     82 |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">1 row in set (0.85 sec)</div><div class="line"></div><div class="line">mysql&gt; alter table emp add primary key(empno);</div><div class="line">Query OK, 4000000 rows affected (9.47 sec)</div><div class="line">Records: 4000000  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line">mysql&gt; select * from emp where empno=3456789;</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| empno   | ename  | job      | mgr | hiredate   | sal     | comm   | deptno |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">| 3456789 | mFmwwU | SALESMAN |   1 | 2017-05-05 | 2000.00 | 400.00 |     82 |</div><div class="line">+---------+--------+----------+-----+------------+---------+--------+--------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;发现时间明显变少，这就是主键索引的作用，按主键单位时间定为到准确位置，而不是从头开始找。</p>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>&#160; &#160; &#160; &#160;一般来说，普通索引的创建，是先创建表，然后在创建普通索引。</p>
<p>&#160; &#160; &#160; &#160;比如:</p>
<pre><code>//先建表
create table ccc(
id int unsigned,
name varchar(32)
)
//添加索引
create index 索引名 on 表 (列1,列名2);
</code></pre><h3 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h3><p>&#160; &#160; &#160; &#160;全文索引，主要是在很针对文件、文本的检索、比如文章，全文索引仅针对MyISAM有用。我们在测试样本temp库中创建下表，并插入测试数据如下：</p>
<h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><pre><code>mysql&gt; CREATE TABLE articles (
    -&gt;        id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    -&gt;        title VARCHAR(200),
    -&gt;        body TEXT,
    -&gt;        FULLTEXT (title,body)
    -&gt;      )engine=myisam charset utf8;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; INSERT INTO articles (title,body) VALUES
    -&gt;      (&apos;MySQL Tutorial&apos;,&apos;DBMS stands for DataBase ...&apos;),
    -&gt;      (&apos;How To Use MySQL Well&apos;,&apos;After you went through a ...&apos;),
    -&gt;      (&apos;Optimizing MySQL&apos;,&apos;In this tutorial we will show ...&apos;),
        -&gt;      (&apos;1001 MySQL Tricks&apos;,&apos;1. Never run mysqld as root. 2. ...&apos;),
    -&gt;      (&apos;MySQL vs. YourSQL&apos;,&apos;In the following database comparison ...&apos;),
    -&gt;      (&apos;MySQL Security&apos;,&apos;When configured properly, MySQL ...&apos;);
Query OK, 6 rows affected (0.00 sec)
Records: 6  Duplicates: 0  Warnings: 0
</code></pre><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>然后使用下面命令看是否成功,其中\G代表按行打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; show index from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h4 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h4><p>&#160; &#160; &#160; &#160;使用explain来分析一个错误使用全文索引的语句。</p>
<pre><code>mysql&gt; explain select * from articles where body like &quot;%mysql%&quot;\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: articles
   partitions: NULL
         type: ALL
possible_keys: NULL
      key: NULL
  key_len: NULL
      ref: NULL
     rows: 6
 filtered: 16.67
    Extra: Using where
1 row in set, 1 warning (0.00 sec)
</code></pre><p>可看到possible_keys: NULL，key: NULL，说明没用到，下面例子就看到使用到了title。</p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><font color="red">正确的用法：WHERE  MATCH(title,body) against(‘database’);</font>


<pre><code>mysql&gt; explain select * from articles where match(title,body)     against(&apos;database&apos;)\G; 
*************************** 1. row ***************************
       id: 1
  select_type: SIMPLE
        table: articles
   partitions: NULL
     type: fulltext
possible_keys: title
          key: title
      key_len: 0
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
</code></pre><p>&#160; &#160; &#160; &#160;说明：</p>
<ol>
<li>在mysql中fulltext 索引只针对 myisam生效</li>
<li>mysql自己提供的fulltext针对英文生效-&gt;sphinx (coreseek) 技术处理中文</li>
<li>使用方法是 match(字段名..) against(‘关键字’)</li>
<li>全文索引一个 叫 停止词,  因为在一个文本中，创建索引是一个无穷大的数，因此，对一些常用词和字符，就不会创建，这些词，称为停止词.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; select match(title,body) against(&apos;a&apos;) from articles;</div><div class="line">+--------------------------------+</div><div class="line">| match(title,body) against(&apos;a&apos;) |</div><div class="line">+--------------------------------+</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">|                              0 |</div><div class="line">+--------------------------------+</div><div class="line">6 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>&#160; &#160; &#160; &#160;当表的某列被指定为unique约束时，这列就是一个唯一索引。按照以下方式建表，name列就是唯一索引。<font color="red">唯一索引允许为空，而且允许多个。</font></p>
<h4 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h4><pre><code>mysql&gt; create table ddd(id int primary key auto_increment , name varchar(32)     unique);
Query OK, 0 rows affected (0.02 sec)
</code></pre><h4 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h4><p>&#160; &#160; &#160; &#160;在创建表后，再去创建唯一索引，见如下指令：</p>
<pre><code>create table eee(id int primary key auto_increment, name varchar(32));

create unique index 索引名  on 表名 (列表..);
</code></pre><h2 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h2><p>desc 表名 【该方法的缺点是：　不能够显示索引名.】</p>
<p>show index(es) from 表名</p>
<p>show keys from 表名</p>
<h4 id="1-3"><a href="#1-3" class="headerlink" title="1"></a>1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mysql&gt; desc articles</div><div class="line">    -&gt; ;</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">| Field | Type             | Null | Key | Default | Extra          |</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |</div><div class="line">| title | varchar(200)     | YES  | MUL | NULL    |                |</div><div class="line">| body  | text             | YES  |     | NULL    |                |</div><div class="line">+-------+------------------+------+-----+---------+----------------+</div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; show index from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div><div class="line"></div><div class="line">ERROR: </div><div class="line">No query specified</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">mysql&gt; show keys from articles\G;</div><div class="line">*************************** 1. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 0</div><div class="line">     Key_name: PRIMARY</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: id</div><div class="line">    Collation: A</div><div class="line">  Cardinality: 6</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: </div><div class="line">   Index_type: BTREE</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 2. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 1</div><div class="line">  Column_name: title</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">*************************** 3. row ***************************</div><div class="line">        Table: articles</div><div class="line">   Non_unique: 1</div><div class="line">     Key_name: title</div><div class="line"> Seq_in_index: 2</div><div class="line">  Column_name: body</div><div class="line">    Collation: NULL</div><div class="line">  Cardinality: NULL</div><div class="line">     Sub_part: NULL</div><div class="line">       Packed: NULL</div><div class="line">         Null: YES</div><div class="line">   Index_type: FULLTEXT</div><div class="line">      Comment: </div><div class="line">Index_comment: </div><div class="line">3 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>alter table 表名 drop index 索引名; </p>
<p>如果删除主键索引。</p>
<p>alter table 表名 drop primary key </p>
<h2 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h2><p>先删除再重新创建。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节介绍的如何操作索引和索引能加快查询的原理。下篇我们看看怎么去分析索引的性能，比如explain用法，然后我们该怎么去适用索引最恰当。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;上篇已经建立了测试数据库，然后通过相关工具找到了慢查询的语句，这些就是我们优化的对象，本篇就从索引的角度去改善我们的数据库性能。共四种索引，主键索引、唯一索引、普通索引、全文索引。索引是有消耗的，占空间的，MYI格式文件在data文件夹下。&lt;br&gt;
    
    </summary>
    
      <category term="mysql学习" scheme="http://yoursite.com/categories/mysql%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记整理（二）</title>
    <link href="http://yoursite.com/2017/02/14/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/14/MySQL学习笔记整理（二）/</id>
    <published>2017-02-14T02:08:23.000Z</published>
    <updated>2017-07-15T03:51:08.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;之前已经了解过mysql的基本原理，重点是我们该从哪些方面去改善数据库性能，或者从设计开始怎么样去合适的设计，可以使用哪些工具和方法去帮助我们监测数据库，并根据在数据库原理的理解基础上，对不同的业务需求不同的软硬件环境，尽量做出最优的优化策略。下面就看下有哪些优化方法和适用场景，可以根据实际选用其中一部分进行优化，而且优化是一个整体的，所以不是改变一个方法就能大幅提升性能，也没有确定的套路。本文在看了传智mysql优化课程之后记录的学习笔记。</p>
  <a id="more"></a>
<h2 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h2><p>对mysql优化时一个综合性的技术，主要包括：</p>
<ol>
<li><p>表的设计合理化(符合3NF)</p>
</li>
<li><p>添加适当索引(index) [四种: 普通索引、主键索引、唯一索引unique、全文索引]</p>
</li>
<li>分表技术(水平分割、垂直分割)</li>
<li>读写[写: update/delete/add]分离</li>
<li>存储过程 [模块化编程，可以提高速度]</li>
<li>对mysql配置优化 [配置最大并发数my.ini, 调整缓存大小 ]</li>
<li>mysql服务器硬件升级</li>
<li>定时的去清除不需要的数据,定时进行碎片整理(MyISAM) </li>
</ol>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>表的范式，是首先符合1NF, 才能满足2NF , 进一步满足3NF</p>
<p>&#160; &#160; &#160; &#160;1NF: 即表的列的具有原子性,不可再分解，即列的信息，不能分解, 只有数据库是关系型数据库(mysql/oracle/db2/informix/sysbase/sql server)，就自动的满足1NF。</p>
<p>&#160; &#160; &#160; &#160;2NF: 表中的记录是唯一的, 就满足2NF, 通常我们设计一个主键来实现。</p>
<p>&#160; &#160; &#160; &#160;3NF: 即表中不要有冗余数据, 就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放. 比如下面的设计就是不满足3NF:</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/3NF.png" alt=""></p>
<p>需要修改成以下，消除依赖：<br><img src="http://opb7t58xj.bkt.clouddn.com/3NF2.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;反3NF : 但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。 </p>
<p>案例 ：<br><img src="http://opb7t58xj.bkt.clouddn.com/%E5%8F%8D3NF.png" alt=""></p>
<h3 id="show-status"><a href="#show-status" class="headerlink" title="show status"></a>show status</h3><p>&#160; &#160; &#160; &#160;查看mysql配置参数。我的运行环境是Mac，mysql5.7.18，如下图：<br><img src="http://opb7t58xj.bkt.clouddn.com/showstatus.png" alt=""><br>从图中可知，有356个变量，其中我们需要熟悉一部分，知道它代表的意义，可用下面指令查具体的：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/show%20like.png" alt=""></p>
<p>注意：这里结束符非常重要，区分中英文符号，是结束一条命令的标志。。。。。存储过程中还要改。因为存储过程中就有分号。</p>
<p>这里放两个链接：<a href="http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html" target="_blank" rel="external">mysql 命令大全</a>，<a href="http://blog.itpub.net/15480802/viewspace-764968/" target="_blank" rel="external">mysql较为重要的状态变量</a>。</p>
<p>&#160; &#160; &#160; &#160;那我们如何从一个大项目中，迅速的定位执行速度慢的语句. (定位慢查询)，比如首先我们了解mysql数据库的一些运行状态如何查询(比如想知道当前mysql运行的时间/一共执行了多少次select/update/delete.. / 当前连接)。实现如下：</p>
<p><em>show status</em></p>
<ol>
<li><p>常用的:<br>show status like ‘uptime’ ;<br>show  stauts like ‘com_select’  show stauts like ‘com_insert’ …类推 update  delete</p>
</li>
<li><p>show [session|global] status like …. 如果你不写  [session|global] 默认是session 会话，指取出当前窗口的执行，如果你想看所有(从mysql 启动到现在，则应该 global)</p>
</li>
<li><p>show status like ‘connections’; </p>
</li>
<li><p>show status like ‘slow_queries’;//显示慢查询次数</p>
</li>
</ol>
<h3 id="压力测试脚本生成"><a href="#压力测试脚本生成" class="headerlink" title="压力测试脚本生成"></a>压力测试脚本生成</h3><p>&#160; &#160; &#160; &#160;如何去定位慢查询呢，我们想还原一个场景，那我们就要构建一个大表(400 万)，我们采用存储过程构建，默认情况下，mysql认为10秒才是一个慢查询.所以我们要修改mysql的慢查询时间.使用以下命令：</p>
<p>show variables like ‘long_query_time’ ; //可以显示当前慢查询时间</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/60AEBD45-4A1C-4709-90F9-04324FBB4197.png" alt=""></p>
<p>set long_query_time=1 ;//可以修改慢查询时间</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/manchaxun.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;而且我们构建的大表中记录是有要求的,为了满足真实性，我们采取了随机生成的方法 ，使记录不同从而使测试效果和真实的相差不大。存储过程源码我放在了GitHub上，地址如下，无耻的求个star或者fork：<a href="https://github.com/wustzoujing/BetterMysqlTestDemo" target="_blank" rel="external">wustzoujing/BetterMysqlTestDemo</a>；简要的记录下我的执行过程；<br>首先写了两个随机函数，产生指定长度的两个字符串或者数字。其中rand_string()执行结果如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;上图可以知道：其中dual是亚元表，就是空表，已经随机生成了6位字符串。接下来看看存储过程执行成功如下：</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/cunshuguochen.png" alt=""></p>
<p>&#160; &#160; &#160; &#160;最后我们调用存储过程，执行几分钟后，看下结果，已经插入成功。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/shuju.png" alt=""></p>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>这时我们已经有慢查询的次数了，就是插入数据这条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;long_query_time&apos;</div><div class="line"></div><div class="line">    -&gt; ;</div><div class="line">    </div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">| Variable_name   | Value    |</div><div class="line"></div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">| long_query_time | 1.000000 |</div><div class="line"></div><div class="line">+-----------------+----------+</div><div class="line"></div><div class="line">1 row in set (0.01 sec)</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;然后我们需要开启慢查询日志（不同操作系统不同设置方式和文件路径，百度应该有很多），然后重启mysql，上面就会记录着我们的慢查询语句是什么。如下图，这是我的结果。</p>
<p><img src="http://opb7t58xj.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-05%20%E4%B8%8B%E5%8D%885.16.25.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;这里我们主要是形成测试样本，利用慢查询工具，这只是一个例子，还有很多命令方法工具帮助我们来找出问题，可以参考手册来。下篇博客讲讲发现问题了，我们如何优化。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;之前已经了解过mysql的基本原理，重点是我们该从哪些方面去改善数据库性能，或者从设计开始怎么样去合适的设计，可以使用哪些工具和方法去帮助我们监测数据库，并根据在数据库原理的理解基础上，对不同的业务需求不同的软硬件环境，尽量做出最优的优化策略。下面就看下有哪些优化方法和适用场景，可以根据实际选用其中一部分进行优化，而且优化是一个整体的，所以不是改变一个方法就能大幅提升性能，也没有确定的套路。本文在看了传智mysql优化课程之后记录的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql学习" scheme="http://yoursite.com/categories/mysql%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql优化" scheme="http://yoursite.com/tags/mysql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习笔记整理（一）</title>
    <link href="http://yoursite.com/2017/02/13/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/13/MySQL学习笔记整理（一）/</id>
    <published>2017-02-13T03:08:56.000Z</published>
    <updated>2017-07-13T03:13:13.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#160; &#160; &#160; &#160;数据库是后台开发重中之重的一个环节，了解当前各种类型的数据库，并在了解各种数据库设计原理的基础上，深入学习相关优化策略，加之以实战经验，才是长久的发展之计。之后对先对关系型数据库–mysql为例进行深入学习笔记记录，毕竟开源，而且也是世界顶级的数据库，然后对非关系型数据库NoSql进行学习，以Redis为例，这些都已经接触过了，之后将做一个总结的笔记。</p>
  <a id="more"></a>
<h2 id="数据库的种类"><a href="#数据库的种类" class="headerlink" title="数据库的种类"></a>数据库的种类</h2><ol>
<li>对象数据库 应用领域：地理信息系统、科学与统计数据库、多媒体系统、XML文档仓库。</li>
<li>对象关系数据库 了解一下</li>
<li>关系数据库，例如mysql、oracle、sql server、db2等。我们以mysql为例深入了解关系数据库。</li>
<li>介于关系数据库与非关系数据库之间的MongoDB和完全的非关系数据库NoSql的Redis。Redis是我们了解的重点。</li>
</ol>
<h2 id="mysql数据库系统"><a href="#mysql数据库系统" class="headerlink" title="mysql数据库系统"></a>mysql数据库系统</h2><p>&#160; &#160; &#160; &#160;mysql由SQL接口、解析器、查询优化器、查询缓存（缓存和缓冲区）、存储引擎等几个子系统构成。</p>
<p><img src="http://img1.51cto.com/attachment/201308/111054362.png?_=3641983" alt=""></p>
<p>&#160; &#160; &#160; &#160;图中还有几个部分解释如下：</p>
<p>connectors：与其他编程语言中的sql 语句进行交互，如php、java等；</p>
<p>Management Serveices &amp; Utilities：系统管理和控制工具；</p>
<p>Connection Pool (连接池)：管理缓冲用户连接，线程处理等需要缓存的需求。下面我们一个一个的来了解。</p>
<h3 id="SQL接口"><a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h3><p>&#160; &#160; &#160; &#160;SQL提供了从用户接收命令并把结果返回给用户的机制。关系数据库大都支持SQL标准，基本语句都类似，比如常规的CURD操作，sql server和mysql就差不多。mysql是一个多线程应用，它为每一个连接创建一个线程，每个线程执行都独立于其他线程。接收到SQL命令，解析各个部分存入一个类结构，查询结果通过有关数据写到网络通信协议上传输给客户端。</p>
<h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>解析器使用Lex和YACC实现，它能够把一条SQL语句分解为命令字、选项和参数等一系列最基本的语法元素，并将这些存入一个Lex类的结构中，后面查询步骤都会使用这个。规则使用Lex和YACC编写，在使用Bison编译成一个词法解析器。</p>
<h3 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h3><p>&#160; &#160; &#160; &#160;查询优化策略有很多，也可以设计优化算法，高阶程序员也可以自己写查询优化器代替mysql默认的。sql server使用的查询优化策略是基于开销的，根据一系列等价规则为给定查询生成一系列查询评估计划，然后根据关于执行这个查询所需要的关系和操作性能指标数据中选出开销最小的。mysql是混合使用多种优化技术的数据库系统，围绕着选取-投影-联结策略而设计出来的，从整体上能保证生成好的，但不能保证生成最好的查询语句。属于启发式查询优化机制。</p>
<p>&#160; &#160; &#160; &#160;具体的 <strong>选取-投影-联结</strong> 策略 ：即先更具有关的限制条件进行选取（select操作）以减少要处理的元组个数，再进行投影以减少被选取元组里的属性字段的个数，最后根据联结条件生成最终的查询结果。</p>
<ol>
<li>通过计算where子句里的表达式来横向排除多余的数据。</li>
<li>只保留在属性清单里面列出来的，以及在最后执行连接子句时还需要用到的属性字段，其他数据全部排除。</li>
<li>根据联结条件生成最终的查询结果。</li>
</ol>
<p>&#160; &#160; &#160; &#160;优化的第一步检查有关的表是否存在以及用户的访问权限。发现错误返回出错信息并把控制器交给线程管理器，也就是负责监听请求的listener，一旦找到了正确的表，就打开并应用适当的并发控制。<br>&#160; &#160; &#160; &#160;所有的维护和初识化任务完成后，优化器将利用Lex结构对命令中where条件进行处理，其结果作为临时表返回后续步骤做一步处理。如果查询命令里面有UNION操作法，优化器将以循环方式执行完所有的select操作之后再进行下一步。<br>&#160; &#160; &#160; &#160;优化器下一步时执行投影操作。这一步中间结果保存在临时表中且只保存指定列。最后检查Lex结构是否含有Join条件；如果有，调用join优化方法。</p>
<p>&#160; &#160; &#160; &#160;优化内容：对条件表达式进行简化和求值，消除死分支或恒真恒假条件。总之，在执行联结操作之前，优化器会尽量减小查询命令里的条件。</p>
<h3 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h3><p>&#160; &#160; &#160; &#160;查询的具体执行是由一组库方法实现，每种方法复制一种特点操作，例如CRUD。方法都有一个线程对象参数，可以让那些方法直接找到合线程访问相关的内部查询结构，加快执行速度。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>&#160; &#160; &#160; &#160;查询缓存，包括查询语句解析结果和查询结果本身。把频率最高的数据放在内存中能够快速的访问来加快。速度。mysql把数据封装成某个结构（不同对象缓存，用来封装的结构不同），再把数据保存为一个链表。缓存友表缓存（为了减少打开读取和关闭表，frm文件）、记录缓存（减少数据读写频率）、键缓存（缓存各索引的热度）、权限缓存（授权信息，存为先进后出的散列表）、主机名缓存（用栈）、其他类似联结缓存。缓存有自己的监控机制，利用LRU最近最少使用页面靠换策略。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>&#160; &#160; &#160; &#160;这个是重要的一环，也是mysql最佳功能之一。数据库使用者可以根据需求选择不同的存储引擎，存储引擎是关键的一部，也是数据库管理系统最底层的一个，直接与数据库文件进行交互，也就是对数据库进行IO操作。下面介绍mysql提供的一些存储引擎。</p>
<ol>
<li>MyISAM 是默认的存储引擎，它在ISAM上增加了一些新的缓存和索引机制。为了提高访问速度，这类表还普遍使用了数据压缩和索引优化技术。<font color="red">此外还准备了表级的锁定机制。所以适合检索读性能。</font></li>
<li>InnoDB 几乎总是用在需要支持事务的应用程序。支持ACID，InnoDB所有索引采用B-树结构，放在叶子节点里。改进了并发控制，提供行级的锁定。所以对频繁更新，添加，删除等类型数据库是首选存储引擎。</li>
<li>BDB提供页面即的锁。支持散列表、B-树。</li>
<li>内存存储引擎。HEAP表。</li>
<li>合并存储引擎。安装特定规则分成很多小表去存储一个大表，搜索的时候可以去搜索特定的小表而不是搜索体积庞大的大表。但是缺点是：只能用相同的myisam表，不允许替换操作，与普通表相比，使用索引访问效率要低。</li>
<li>档案。把大量数据保存为压缩格式，适合存放和检索那些不需要频繁更新的档案性或历史积累数据。比如系统日志。</li>
<li>联合存储引擎。适合用在分布式环境</li>
<li>群集／NDB 。 在一个高可用性和高性能的环境中使用多个mysql服务器提供数据库服务。</li>
<li>其他的包括：CSV、黑洞、定制的。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;了解了一下数据库的类型，和mysql的组成，对RDBS的设计有了大致的了解，那么后面将对在此基础上对mysql优化进行一个深度的学习和总结，并找demo来实战。下面对SQL 语句执行过程进行说明：</p>
<p>   &#160; &#160; &#160; &#160;数据库通常不会被直接使用，而是由其他编程语言通过SQL语句调用mysql，由mysql处理并返回执行结果。那么Mysql接受到SQL语句后，又是如何处理的呢？</p>
<p>   &#160; &#160; &#160; &#160;首先程序的请求会通过mysql的connectors与其进行交互，请求到处后，会暂时存放在连接池（connection pool)中并由处理器（Management Serveices&amp;Utilities）管理。当该请求从等待队列进入到处理队列，管理器会将该请求丢给SQL接口（SQL Interface）。SQL接口接收到请求后，它会将请求进行hash处理并与缓存中的结果进行对比，如果完全匹配则通过缓存直接返回处理结果；否则，需要完整的走一趟流程：</p>
<ol>
<li><p>由SQL接口丢给后面的解释器（Parser），上面已经说到，解释器会判断SQL语句正确与否，若正确则将其转化为数据结构。</p>
</li>
<li><p>解释器处理完，便来到后面的优化器（Optimizer），它会产生多种执行计划,最终数据库会选择最优化的方案去执行,尽快返会结果。</p>
</li>
<li><p>确定最优执行计划后，SQL语句此时便可以交由存储引擎（Engine）处理，存储引擎将会到后端的存储设备中取得相应的数据，并原路返回给程序。</p>
</li>
<li><p>这里有几点需要注意：</p>
</li>
</ol>
<p>&#160; &#160; &#160; &#160;(1)如何缓存查询数据？</p>
<p>&#160; &#160; &#160; &#160;存储引擎处理完数据，并将其返回给程序的同时，它还会将一份数据保留在缓存中，以便更快速的处理下一次相同的请求。具体情况是，mysql会将查询的语句、执行结果等进行hash，并保留在cache中，等待下次查询。</p>
<p>&#160; &#160; &#160; &#160;(2)buffer与cache的区别？</p>
<p>&#160; &#160; &#160; &#160;从上面的图可以看到，缓存那里实际上有buffer和cache两个，那它们之间是否有什么不同呢？简单的说就是，buffer是写缓存，cache是读缓存。</p>
<p>&#160; &#160; &#160; &#160;(3)如何判断缓存中是否已缓存需要的数据</p>
<p>&#160; &#160; &#160; &#160;这里可能有一个误区，觉得处理SQL语句的时候，为了判断是否已缓存查询结果，会将整个流程走一遍，取得执行结果后再与需要的进行对比，看看是否命中，并以此说，既然不管缓存中有没有缓存到查询内容，都要整个流程走一遍，那么缓存的优势又在哪里？？</p>
<p>&#160; &#160; &#160; &#160;实际上，并非如此，在第一次查询后，mysql便将查询语句以及查询结果进行hash处理并保留在缓存中，SQL查询到达之后，对其进行同样的hash处理后，将两个hash值进行对照，如果一样，则命中，从缓存中返回查询结果；否则，需要整个流程走一遍。</p>
<p>链接参考：<a href="http://pmghong.blog.51cto.com/3221425/1281970" target="_blank" rel="external">mysql原理</a></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&#160; &#160; &#160; &#160;文中出现的图片，文字描述有些来自互联网，但是出处无法考究，如果侵犯您的相关权益，请联系我，核实后我会马上加上转载说明。谢谢！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;数据库是后台开发重中之重的一个环节，了解当前各种类型的数据库，并在了解各种数据库设计原理的基础上，深入学习相关优化策略，加之以实战经验，才是长久的发展之计。之后对先对关系型数据库–mysql为例进行深入学习笔记记录，毕竟开源，而且也是世界顶级的数据库，然后对非关系型数据库NoSql进行学习，以Redis为例，这些都已经接触过了，之后将做一个总结的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql学习" scheme="http://yoursite.com/categories/mysql%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：用两个栈实现队列</title>
    <link href="http://yoursite.com/2017/01/24/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2017/01/24/算法：用两个栈实现队列/</id>
    <published>2017-01-24T10:25:17.000Z</published>
    <updated>2017-08-12T03:10:10.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　栈和队列是非常常见的数据结构。栈先进后出，队列先进先出，Java中有定义好的栈和队列数据结构。要熟悉源码。栈和队列也有很多的联系，本题就是用两个栈实现一个队列。</p>
  <a id="more"></a>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>　　用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;我们知道栈是先进后出，而队列是先进先出。两个栈是可以实现先进后出的，我们模拟进队列操作时，进队列都进入第一个栈，然后出队列操作时，先把栈1全部倒入栈2，栈2出栈完成出队列操作，为了保证顺序，栈2中元素还要在倒入栈1。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    //定义两个栈</div><div class="line">    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</div><div class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</div><div class="line">    //进队都往第一个栈进。</div><div class="line">    public void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line">    //出队列函数</div><div class="line">    public int pop() &#123;</div><div class="line">        //如果栈1不为空，把栈1值导入栈2，完成逆序</div><div class="line">        while(!stack1.isEmpty())&#123;</div><div class="line">            stack2.push(stack1.pop());</div><div class="line">        &#125;</div><div class="line">        //栈2栈顶出队列</div><div class="line">        int first=stack2.pop();</div><div class="line">        //这里是重点：栈2的值都要倒回栈1，因为如果不倒回，出队列操作之后，栈2还有元素，但是之</div><div class="line">        //后进队列的元素又倒回栈2，这样就乱序了，倒回保证每次栈2中先进的都在下面，整体倒入栈2</div><div class="line">        //后肯定保证是先进的元素在栈顶</div><div class="line">        while(!stack2.isEmpty())&#123;</div><div class="line">            stack1.push(stack2.pop());</div><div class="line">        &#125;</div><div class="line">        //</div><div class="line">        return first;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;　　栈和队列是非常常见的数据结构。栈先进后出，队列先进先出，Java中有定义好的栈和队列数据结构。要熟悉源码。栈和队列也有很多的联系，本题就是用两个栈实现一个队列。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer：旋转数组的最小数字</title>
    <link href="http://yoursite.com/2017/01/23/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2017/01/23/算法：旋转数组的最小数字/</id>
    <published>2017-01-23T06:23:32.000Z</published>
    <updated>2017-08-11T04:36:32.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>　　这道题找数组中的最小数字，类似的题目之前蘑菇街视频面试都考过，找数组中的最大的两个值或者三个值。直观解题方法就是循环一遍数组，这样的复杂度是O（n），但是由题目可知，数组已部分排序，我们利用二分查找的方法是可以减少我们的复杂度的，达到O（log n）。</p>
  <a id="more"></a>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>　　把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&#160; &#160; &#160; &#160;二分查找法的核心思想就是：每次查找都可以排除不需要查找的一半，这道题我们是可以利用这个思想的。</p>
<p>&#160; &#160; &#160; &#160;我们定义两个标志，初识是分别指向第一位和最后一位，按照题目的旋转规则，我们找到数组中间的元素，如果中间的元素位于前面的递增数组中，那他应该小于等于第二个个标志指向的元素，此时数组中最小的元素应该位于该中间元素的后面，排除了一半，利用了二分的思想；同样，如果中间元素位于后面递增子数组中，那么它应该大于等于第二个标志指向的元素。如果相等，把最高位往前移一位，最后第一个标志上就是最小值。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class minNumberInRotateArray_6 &#123;</div><div class="line"></div><div class="line">    public int minNumberInRotateArray(int [] array) &#123;</div><div class="line"></div><div class="line">        //定义两个标志指向首位索引</div><div class="line">        int low = 0 ; int high = array.length - 1;</div><div class="line">        //结束条件</div><div class="line">        while(low &lt; high)&#123;</div><div class="line">            //取中间元素</div><div class="line">            int mid = low + (high - low) / 2;</div><div class="line">            //中间元素比尾数大，最小值在后半段</div><div class="line">            if(array[mid] &gt; array[high])&#123;</div><div class="line">                low = mid + 1;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            //如果相等，高位减1</div><div class="line">            else if(array[mid] == array[high])&#123;</div><div class="line">                high = high - 1;</div><div class="line">            &#125;</div><div class="line">            //如果中间元素比尾数小，最小值在前半段</div><div class="line">            else&#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //循环结束，低位标志就是最小值所在</div><div class="line">        return array[low];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;　　这道题找数组中的最小数字，类似的题目之前蘑菇街视频面试都考过，找数组中的最大的两个值或者三个值。直观解题方法就是循环一遍数组，这样的复杂度是O（n），但是由题目可知，数组已部分排序，我们利用二分查找的方法是可以减少我们的复杂度的，达到O（log n）。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer详解" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer%E8%AF%A6%E8%A7%A3/"/>
    
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
