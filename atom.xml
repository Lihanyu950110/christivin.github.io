<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐盛的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-12T09:20:28.132Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>徐盛</name>
    <email>544915551@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Java虚拟机（二）</title>
    <link href="http://yoursite.com/2017/01/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/04/深入理解Java虚拟机（二）/</id>
    <published>2017-01-04T02:10:16.000Z</published>
    <updated>2017-05-12T09:20:28.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p><strong>本章主要内容</strong></p>
<ul>
<li>对象访问</li>
</ul>
<hr>
<p>在Java中，对象访问是如何进行的？</p>
<p>　　对象访问在Java中无处不在，是最普通的程序行为，但是最简单的访问也会涉及 <strong>Java栈、Java堆、方法区</strong>这三个最重要的内存区域之间的关联关系。如：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object obj = new Object();</div></pre></td></tr></table></figure>
<p>　　其中， <code>Object obj</code>这部分的语义会反映到Java栈的本地变量表中，最为一个reference类型数据出现。而 <code>new Object()</code>这部分的语义会反映到Java堆中，形成一块存储了Object类型所有实例数据值的结构化内存，根据具体类型及虚拟机实现的对象内存布局不同，这块内存是不固定的。在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。</p>
<h2 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h2><p>主流的访问方式有两种：</p>
<ul>
<li><strong>句柄访问方式</strong>，Java堆中将会划分出一块内存来作为 <strong>句柄池</strong>，引用类型数据中存储的就是对象的句柄地址，句柄中包含了 <strong>对象实例数据</strong>和 <strong>类型数据</strong> 各自的具体地址信息。</li>
</ul>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt=""></p>
<ul>
<li><strong>直接指针访问方式</strong>，引用类型数据中存储的就是对象地址。</li>
</ul>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt=""></p>
<style>
table th:first-of-type {
    width: 100px;
}
</style>

<table>
<thead>
<tr>
<th style="text-align:left">访问方式</th>
<th>优点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">句柄访问</td>
<td>reference中存储的是稳定的句柄地址，在对象被移动中只会改变句柄中实例数据指针，而reference本身不必修改</td>
</tr>
<tr>
<td style="text-align:left">直接指针访问</td>
<td>速度快，节省了一次指针定位的时间开销</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象访问&quot;&gt;&lt;a href=&quot;#对象访问&quot; class=&quot;headerlink&quot; title=&quot;对象访问&quot;&gt;&lt;/a&gt;对象访问&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本章主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象访问&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;在Java中，对象访问是如何进行的？&lt;/p&gt;
&lt;p&gt;　　对象访问在Java中无处不在，是最普通的程序行为，但是最简单的访问也会涉及 &lt;strong&gt;Java栈、Java堆、方法区&lt;/strong&gt;这三个最重要的内存区域之间的关联关系。如：&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="对象访问" scheme="http://yoursite.com/tags/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>深入学习JAVA虚拟机（一）</title>
    <link href="http://yoursite.com/2017/01/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/03/深入理解JAVA虚拟机（一）/</id>
    <published>2017-01-03T12:11:32.000Z</published>
    <updated>2017-05-12T08:13:10.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java内存区域与内存溢出异常"><a href="#java内存区域与内存溢出异常" class="headerlink" title="java内存区域与内存溢出异常"></a>java内存区域与内存溢出异常</h2><hr>
<p><strong>本章主要内容</strong></p>
<ul>
<li>运行时数据区域</li>
</ul>
<hr>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把他所管理的内存划分成若干不同的数据区域。<br>  <img src="http://oppqlui3e.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt=""></p>
<p>  　　这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。<br><a id="more"></a></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h4><p>　　程序计数器(Program Counter Register) 是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，<strong>分支、循环、跳转、异常处理、线程恢复等</strong>基础功能都需要依赖这个计数器来完成。</p>
<ul>
<li>Java虚拟机的多线程通过轮流切换并分配处理器执行时间实现。</li>
<li>在任何一个确定的时刻，一个处理器只会执行一条线程的指令。</li>
<li>每个线程都有一个独立的程序计数器，线程切换后，找到正确的执行位置。</li>
<li>各线程之间的计数器独立存储。</li>
</ul>
<p>　　如果线程正在执行的是一个Java方法，这个计数器记录的时正在执行的虚拟机字节码指令的地址；如果正在执行的是<strong>Native方法</strong>，这个计数器的值为空。此内存区域是唯一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a><strong>Java虚拟机栈</strong></h4><p>　　与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同。它描述的Java方法执行的内存模型。</p>
<ul>
<li>每个方法被执行的时候会创建一个栈帧(Stack Frame)。</li>
<li>栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。</li>
<li>方法从被调用到执行完成对应着一个栈帧在虚拟机栈中入站到出站的过程。</li>
</ul>
<p>通常最关注的、与对象内存分配关系最密切的内存区就是<strong>虚拟机栈</strong>（局部变量表）和<strong>Java堆</strong>。<br><strong>局部变量表</strong>存放了编译器可知的各种基本数据类型：</p>
<ul>
<li>byte (1 Slot)</li>
<li>short(1 Slot)</li>
<li>int(1 Slot)</li>
<li>char(1 Slot)</li>
<li>float(1 Slot)</li>
<li>long(2 Slot)</li>
<li>double(2 Slot)</li>
<li>boolean(1 Slot)</li>
</ul>
<p>　　其中64位长度的long 和double类型的数据会占用2个局部变量空间(Slot),其余的只占一个。<br>　　局部变量表所需的内存空间<strong>在编译期间完成分配</strong>，进入一个方法时，这个方法需要在帧中<strong>分配多大的局部变量空间是完全确定的</strong>，在方法运行期间不会改变局部变量表的大小。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h4><p>　　与虚拟机栈的作用类似，虚拟机栈为虚拟机执行<strong>Java方法</strong>（字节码）服务，本地方法栈为虚拟机的<strong>Native方法</strong>服务。具体的虚拟机可以自由实现本地方法栈。</p>
<h4 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a><strong>Java栈</strong></h4><ul>
<li>Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。</li>
<li>Java堆被<strong>所有线程共享</strong>的一块内存区域，在虚拟机启动时创建。</li>
<li>此内存区域唯一目的就是<strong>存放对象实例</strong>。</li>
<li>Java堆是垃圾收集器管理的主要区域。</li>
<li>Java堆只要求逻辑上连续，可以处于物理上不连续的内存空间中。</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h4><ul>
<li>方法区(Method Area) 与Java堆一样，是个各线程共享的内存区域。</li>
<li>用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</li>
<li>不需要连续的内存，还可以选择不实现垃圾收集。</li>
<li>这个区域的内存回收目标主要是<strong>针对常量池的回收</strong>和对<strong>类型的卸载</strong>。</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h4><ul>
<li>运行时常量池(Runtime Constant Pool)是方法区的一部分。</li>
<li>用于存放<strong>编译期</strong>生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li>运行时常量池具备动态性，即运行期间也可能将新的常量放入池中，例如String类的intern()方法。</li>
<li>当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</li>
</ul>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a><strong>直接内存</strong></h4><ul>
<li>不属于虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是被频繁使用。</li>
<li>本机直接内存的分配不受到Java堆大小的限制，但是会受到本机总内存(RAM及SWAP区或分页文件)的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时一般会根据实际内存设置-Xmx等参数信息，但是经常忽略直接内存，使得各个内存区域的总和大于物理内存限制，导致动态扩展时出现OutOfMemoryError异常。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java内存区域与内存溢出异常&quot;&gt;&lt;a href=&quot;#java内存区域与内存溢出异常&quot; class=&quot;headerlink&quot; title=&quot;java内存区域与内存溢出异常&quot;&gt;&lt;/a&gt;java内存区域与内存溢出异常&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;本章主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时数据区域&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h3&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中会把他所管理的内存划分成若干不同的数据区域。&lt;br&gt;  &lt;img src=&quot;http://oppqlui3e.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  　　这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。&lt;br&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="内存区域" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记整理（一）</title>
    <link href="http://yoursite.com/2016/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/09/17/计算机网络笔记整理（一）/</id>
    <published>2016-09-17T01:42:09.000Z</published>
    <updated>2017-05-16T05:43:12.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h3><p>　　因特网是世界上最大的互连网络，习惯上大家把连接在因特网上的计算机都称为主机（host）。网络互连并不是把计算机简单地在物理上连接起来，还需要计算机安装能够交互信息的软件。</p>
<h4 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h4><p>　　 <strong>第一阶段是从单个网络ARPANET向互联网发展的过程</strong>。1969年美国国防部创建的第一个分组交换网ARPANET最初只是一个单个的分组交换网(并不是一个互连的网络)。所有要连接在ARPANET上的主机都直接与就近的结点交换机相连。 <strong>但到了上世纪70年代中期，人们己认识到不可能仅使用一个单独的网络来满足所有的通信问题。于是ARPA开始研究多种网络(如分组无线电网络)互连的技术，这就导致后来互连网的出现。</strong>这样的互连网就成为现在因特网((Internet)的雏形。 <strong>1983年，TCP/IP协议成为ARPANET上的标准协议</strong>，使得所有使用TCP/IP协议的计算机都能利用互连网相互通信，因而人们就把1983年作为因特网的诞生时间。1990年，ARPANET正式宣布关闭，因为它的实验任务己经完成。<br><a id="more"></a><br>　　 <strong>第二阶段的特点是建成了三级结构的因特网</strong>。从1985年起，美国国家科学基金会NSF(National Science Foundation)就围绕六个大型计算机中心建设计算机网络，即国家科学基金网NSFNET。它是一个三级计算机网络，分为 <strong>主干网、地区网和校园网(或企业网)</strong>。这种三级计算机网络覆盖了全美国主要的大学和研究所，并且成为因特网中的主要组成部分。1991年，NSF和美国的其他政府机构开始认识到， <strong>因特网必将扩大其使用范围，不应仅限于大学和研究机构</strong>。世界上的许多公司纷纷接入到因特网，网络上的通信量急剧增大，使因特网的容量己满足不了需要。于是美国政府决定将因特网的主干网转交给私人公司来经营，并开始对接入因特网的单位收费。1992年因特网上的主机超过100万台。1993年因特网主干网的速率提高到45Mb/s (T3速率)。</p>
<p>　　 <strong>第三阶段的特点是逐渐形成了多层次ISP结构的因特网</strong>。从1993年开始，由美国政府资助的NSFNET逐渐被若干个商用的 <strong>因特网主干网</strong>替代，而政府机构不再负责因特网的运营。这样就出现了一个新的名词: <strong>因特网服务提供者ISP</strong> (Internet Service Provider)。在许多情况下，因特网服务提供者ISP就是一个进行商业活动的公司，因此ISP又常译为 <strong>因特网服务提供商</strong>。例如，中国电信、中国联通和中国移动就是我国最有名的ISP。</p>
<p>　　ISP可以从因特网管理机构申请到很多IP地址(因特网上的主机都必须有IP地址才能上网，同时拥有通信线路(大的ISP自己建造通信线路，小的ISP则向电信公司租用通信线路)以及路由器等连网设备，因此任何机构和个人只要向某个ISP交纳规定的费用，就可从该ISP获取所需IP地址的使用权，并可通过该ISP接入到因特网。 <strong>所谓“上网”就是指“(通过某个ISP获得的IP地址)接入到因特网”</strong>，IP地址的管理机构不会把一个单个的IP地址分配给单个用户(不“零售”IP地址)，而是把一批IP地址有偿租赁给经审查合格的ISP(只“批发”IP地址)。由此可见，现在的因特网已不是某个单个组织所拥有而是全世界无数大大小小的ISP所共同拥有的，这就是因特网也称为“网络的网络”的原因。</p>
<p><strong>注意以下两个意思相差很大的名词Internet和Internet</strong>:</p>
<p>　　以小写字母i开始的Internet(互联网或互连网)是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议(即通信规则)可以是任意的。</p>
<p>　　以大写字母I开始的Internet(因特网)则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP/IP协议族作为通信的规则，且其前身是美国的AIZPANET。</p>
<h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><ul>
<li><strong>边缘部分</strong>由所有连接在因特网上的主机组成。由 <strong>用户直接使用</strong>，进行通信（传输数据，音频或视频）和资源共享。</li>
<li><strong>核心部分</strong>由 <strong>大量网络和连接这些网络的路由器</strong>组成。为 <strong>边缘部分提供服务</strong>（提供连通性和交换）。</li>
</ul>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%90.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<h4 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h4><p>　　 <strong>边缘部分</strong>指的是连接在因特网上的所有主机。这些主机称为端系统。小到个人电脑，大到大型计算机。边缘部分利用核心部分提供的服务，使众多主机之间能互相通信。</p>
<p>　　 <strong>主机A和主机B进行通信</strong>，实际指 运行在主机A上的 <strong>某个程序</strong>和运行在主机B上的另一个程序进行通信。即主机A的 <strong>某个进程</strong>和主机B上的另一个进程进行通信。</p>
<p>边缘系统中程序的通信方式：</p>
<ul>
<li><strong>客户端服务器方式</strong>（C/S方式）</li>
<li><strong>对等方式</strong>（P2P方式）</li>
</ul>
<h5 id="客户端服务器方式"><a href="#客户端服务器方式" class="headerlink" title="客户端服务器方式"></a>客户端服务器方式</h5><ul>
<li><strong>客户端</strong>和 <strong>服务器</strong>都是指通信中所涉及的两个应用进程。</li>
<li>客户服务器方式所描述的是进程之间服务河北服务的关系。</li>
<li>客户是服务的 <strong>请求方</strong>，服务器是服务的 <strong>提供方</strong>。</li>
</ul>
<p>客户A向服务器B发出请求服务，而服务器B向客户A提供服务，如下图：</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<h5 id="客户端服务器方式的特点"><a href="#客户端服务器方式的特点" class="headerlink" title="客户端服务器方式的特点"></a>客户端服务器方式的特点</h5><ul>
<li><strong>客户程序</strong>，被用户调用和运行，在通信时主动向远地服务器发起通信（请求服务）。因此， <strong>客户端程序必须知道服务器程序的地址</strong>。</li>
<li><strong>客户程序</strong>，不需要特殊的硬件和复杂的操作系统。</li>
<li><strong>服务器程序</strong>，可 <strong>同时处理</strong>多个原地或本地客户的请求。</li>
<li><strong>服务器程序</strong>，系统启动后自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此， <strong>不需要知道客户端程序地址</strong>。</li>
<li><strong>服务器程序</strong>，需要强大的硬件和高级的操作系统支持。</li>
</ul>
<h5 id="对等连接方式"><a href="#对等连接方式" class="headerlink" title="对等连接方式"></a>对等连接方式</h5><ul>
<li>两个主机在通信时 <strong>不区分</strong>哪一个式服务请求方还是服务提供方。</li>
<li>只要两个主机都运行了对等连接软件，他们就可以<strong>平等的、对等连接通信</strong>。</li>
<li>可以下载对方已经存储在硬盘中的共享文档。</li>
</ul>
<h5 id="对等连接方式的特点"><a href="#对等连接方式的特点" class="headerlink" title="对等连接方式的特点"></a>对等连接方式的特点</h5><p>本质上，对等连接仍是客户服务器方式，只是对等连接中的每一个主机即是客户又同时是服务器。</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/P2P%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<h4 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h4><ul>
<li>向网络边缘中的大量主机提供 <strong>连通性</strong>，是边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</li>
<li>在核心部分起特殊作用的是路由器。</li>
<li>路由器是实现 <strong>分组交换</strong>的关键构件，其任务是转发收到的分组。</li>
</ul>
<p>三种交换方式：</p>
<ul>
<li>电路交换，整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li>
<li>报文交换，整个报文先传送到相邻结点，全部存储下来后查找转发表，转发下一个结点。</li>
<li>分组交换，单个分组传送到相邻结点，存储下来后查找转发表，转发下一个结点。</li>
</ul>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<h5 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h5><p><img src="http://oppqlui3e.bkt.clouddn.com/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<p>建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）</p>
<p>其特点是，在通话全部时间内，通话的两个用户始终占用端到端的通信资源。</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E5%8D%A0%E7%94%A8%E8%B5%84%E6%BA%90.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""><br>用电路交换来传送计算机数据时， <strong>其线路传输效率往往很低</strong>。</p>
<h5 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h5><p>　　通常把要发送的整块数据称为一个 <strong>报文</strong>。在发送报文前先把较长的报文划分成一个个更小的 <strong>等长数据段</strong>。在每个数据段前加上一些必要的控制信息组成的 <strong>首部</strong>后，就构成了一个 <strong>分组</strong>，分组又称为 <strong>包</strong>。</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E5%88%92%E5%88%86%E5%88%86%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5.png" alt=""><br>分组交换的优点：</p>
<ul>
<li><strong>高效</strong>，动态分配传输带宽，对通信链路是逐段占用。</li>
<li><strong>灵活</strong>，以分组为传送单位和查找路由。</li>
<li><strong>迅速</strong>，不必先建立连接就能向其他主机发送分组。</li>
<li><strong>可靠</strong>，保证可靠性的网络协议，分布式的路由选择协议使网络有很好的生存性。</li>
</ul>
<p>分组交换存在的问题：</p>
<ul>
<li>分组在各个节点存储转发时需要排队，这会造成一定的时延。</li>
<li>分组必须携带首部，造成了一定的开销。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;因特网概述&quot;&gt;&lt;a href=&quot;#因特网概述&quot; class=&quot;headerlink&quot; title=&quot;因特网概述&quot;&gt;&lt;/a&gt;因特网概述&lt;/h3&gt;&lt;p&gt;　　因特网是世界上最大的互连网络，习惯上大家把连接在因特网上的计算机都称为主机（host）。网络互连并不是把计算机简单地在物理上连接起来，还需要计算机安装能够交互信息的软件。&lt;/p&gt;
&lt;h4 id=&quot;因特网发展的三个阶段&quot;&gt;&lt;a href=&quot;#因特网发展的三个阶段&quot; class=&quot;headerlink&quot; title=&quot;因特网发展的三个阶段&quot;&gt;&lt;/a&gt;因特网发展的三个阶段&lt;/h4&gt;&lt;p&gt;　　 &lt;strong&gt;第一阶段是从单个网络ARPANET向互联网发展的过程&lt;/strong&gt;。1969年美国国防部创建的第一个分组交换网ARPANET最初只是一个单个的分组交换网(并不是一个互连的网络)。所有要连接在ARPANET上的主机都直接与就近的结点交换机相连。 &lt;strong&gt;但到了上世纪70年代中期，人们己认识到不可能仅使用一个单独的网络来满足所有的通信问题。于是ARPA开始研究多种网络(如分组无线电网络)互连的技术，这就导致后来互连网的出现。&lt;/strong&gt;这样的互连网就成为现在因特网((Internet)的雏形。 &lt;strong&gt;1983年，TCP/IP协议成为ARPANET上的标准协议&lt;/strong&gt;，使得所有使用TCP/IP协议的计算机都能利用互连网相互通信，因而人们就把1983年作为因特网的诞生时间。1990年，ARPANET正式宣布关闭，因为它的实验任务己经完成。&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络概述" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java基础原理笔记（二）</title>
    <link href="http://yoursite.com/2016/09/11/Java%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/09/11/Java基础原理笔记（二）/</id>
    <published>2016-09-11T08:20:57.000Z</published>
    <updated>2017-05-16T01:57:55.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型和运算符"><a href="#数据类型和运算符" class="headerlink" title="数据类型和运算符"></a>数据类型和运算符</h3><p><strong>本章主要内容</strong></p>
<ul>
<li>基本类型的转换</li>
<li>直接量</li>
<li>运算符</li>
</ul>
<h3 id="基本类型的类型转换"><a href="#基本类型的类型转换" class="headerlink" title="基本类型的类型转换"></a>基本类型的类型转换</h3><hr>
<p>Java语言所提供的7中数值类型之间可以相互转换，有两种转换方式： <strong>自动类型转换、强制类型转换</strong></p>
<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><hr>
<p>　　当把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，西东可以自动类型转换，反之，则需要强制转换。</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt=""><br><a id="more"></a><br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int a = 6;</div><div class="line">float b = a;//此时b的值为6.0</div><div class="line"></div><div class="line">byte c = 7;</div><div class="line">//下面代码将出错，byte类型不能自动转换成char类型</div><div class="line">char d = b;</div></pre></td></tr></table></figure>
<p>　　特别地，当任何基本类型的值和字符串值进行连接运算时，基本类型的值会自动转换成字符串类型的值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String TransToStr = 2.5f + &quot;&quot;;</div><div class="line"></div><div class="line">String Str1 = 3 + 4 + &quot;Hello!&quot;;//Str1的值为 &quot;7Hello!&quot;</div><div class="line"></div><div class="line">String Str2 = &quot;Hello!&quot; + 3 + 4;//Str2的值为 &quot;Hello34&quot;</div></pre></td></tr></table></figure>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><hr>
<p>　　强制类型转换的格式为(targetType)value，需要注意的是，若转换的值超过了目标类型的表数范围，将会引起溢出，造成数据丢失，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int iValue = 233;</div><div class="line">//将int型强制转换成byte型</div><div class="line">byte bValue = (byte)iValue;</div><div class="line">//数据溢出，将输出-23</div><div class="line">System.out.println(bValue);</div><div class="line"></div><div class="line">double dValue = 3.98;</div><div class="line">//将double型强制转换成int型</div><div class="line">int tol = (int)dValue;</div><div class="line">//将输出3</div><div class="line">System.out.println(tol);</div></pre></td></tr></table></figure>
<p>原理：<br><img src="http://oppqlui3e.bkt.clouddn.com/int%E8%BD%ACbyte.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></p>
<p>　　32位int类型的233强制转换为8位的byte类型，需要截断前面的24位，截断后最左一位表示符号位，而负数在计算机中以补码形式存在，则11101001转成原码还需减一取反，得到10010111，即为-23。</p>
<p>另外，有一个容易出错的地方，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//5.6默认是double型的，直接赋给一个float型的变量会出错</div><div class="line">float a = 5.6;</div><div class="line">//应为</div><div class="line">float a = (float)5.6;</div></pre></td></tr></table></figure>
<p>　　一般的，字符串不能直接转换为基本类型，但是可以通过基本类型对应的包装类实现字符串转基本类型，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String a = &quot;25&quot;;</div><div class="line">int iValue = Integer.parseInt(a);</div></pre></td></tr></table></figure>
<p>Java中八种基本类型对应的包装类如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">基本类型</th>
<th style="text-align:center">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:center">Boolean</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:center">Integer</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:center">charcter</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:center">Double</td>
</tr>
</tbody>
</table>
<p>8个包装类均提供parseXxx(String str)静态方法用于将字符串转成对应的基本类型。</p>
<h3 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h3><hr>
<p>能指定直接量的通常只有三种类型： <strong>基本类型、字符类型、null型</strong></p>
<ul>
<li>基本类型： <strong>int、long、float、double、Boolean、char</strong></li>
<li>字符类型： <strong>String</strong></li>
<li>null类型： 只有一个值,即为 <strong>null</strong></li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>String类型的直接量不能赋给其他类型的变量</li>
<li>null类型的直接量可以直接赋给任何引用类型的变量</li>
<li>Boolean类型的直接量只能赋给Boolean类型的变量</li>
</ul>
<p>　　 <strong>关于字符串直接量有一点需要指出</strong>，当程序第一次使用某个字符串直接量时，Java会使用常量池来缓存该字符串直接量，若后续要使用该字符串直接量，Java会直接使用常量池中的该直接量。</p>
<p>　　 <strong>常量池</strong>指的是在编译期被确定，并被保存在已编译的.class魏建忠的一些数据。它包括关于 <strong>类、方法、接口</strong>中的常量，也包括 <strong>字符串常量</strong>。</p>
<p>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String s0 = &quot;hello&quot;;</div><div class="line">String s1 = &quot;hello&quot;;</div><div class="line">String s2 = &quot;he&quot; + &quot;llo&quot;;</div><div class="line">System.out.println( s0 == s1);</div><div class="line">System.out.println( s0 == s2);</div></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div></pre></td></tr></table></figure>
<p>　　因为Java会确保每个字符串常量只有一个，不会产生多个副本。例子中的s0和s1中的”hello”都是字符串常量，他们在编译期就被确定了，所以s0==s1返回true;s2同样在编译器就被解析为一个字符串常量，所以s2也是常量池中”hello”的引用。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><hr>
<p>Java中的算术运算符可分为如下几种：</p>
<ul>
<li><strong>算术运算符</strong></li>
<li><strong>赋值运算符</strong></li>
<li><strong>比较运算符</strong></li>
<li><strong>逻辑运算符</strong></li>
<li><strong>位运算符</strong></li>
<li><strong>类型相关运算符</strong></li>
</ul>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><hr>
<ul>
<li>+：加法运算符</li>
<li>-：减法运算符</li>
<li>*：乘法运算符</li>
<li>/：除法运算符</li>
<li>%：求余运算符</li>
<li>++：自加</li>
<li>–：自减</li>
</ul>
<p><strong>注意</strong>：自加和自减只能用于 <strong>操作变量</strong>，不能用于操作数值直接量、常量或表达式。如：5++、6–都是错误的。</p>
<p>Java没有提供更复杂的运算符，如果要完成乘方、开方等运算，需借助 <strong>java.lang.Math</strong>类的工具方法完成。</p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><hr>
<p>用于为变量指定变量值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;Java&quot;;</div><div class="line"></div><div class="line">String str2 = str;</div></pre></td></tr></table></figure>
<p><strong>把变量当成一个盛装数据的容器，赋值运算就相当于“装入”的过程</strong>。赋值运算符是 <strong>从右向左</strong>执行计算的，程序先计算得到 <code>=</code>右边的值，再把该值装入左边的变量中。因此， <code>=</code>左边只能是变量。</p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><hr>
<ul>
<li>&amp;：按位与。当两位同时为1时才返回1。</li>
<li>|：按位或。只要有一位为1即可返回1。</li>
<li>~：按位非。单目运算符，将操作数的每个位（包括符号位）全部取反。</li>
<li>^ ：按位异或。当两位相同时返回0，不同时返回1。</li>
<li>&lt;&lt;：左移运算符。</li>
<li>＞＞：右移运算符。</li>
<li>＞＞＞：无符号右移运算符。</li>
</ul>
<p>实例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(5 &amp; 9);//输出1</div><div class="line">System.out.println(5 | 9);//输出13</div></pre></td></tr></table></figure>
<p>原理如下：</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E4%B8%8E%E6%88%96%E8%BF%90%E7%AE%97.png" alt=""></p>
<p>按位异或和按位取反：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(~-5);//输出4</div><div class="line">System.out.println(5 ^ 9);//输出12</div></pre></td></tr></table></figure>
<p>按位取反原理如下：<br><img src="http://oppqlui3e.bkt.clouddn.com/%E9%9D%9E%E8%B4%9F5.png" alt=""></p>
<p>按位异或原理如下：<br><img src="http://oppqlui3e.bkt.clouddn.com/59%E5%BC%82%E6%88%96.png" alt=""></p>
<p>左移运算符是将操作数的二进制码整体左移指定位数，左移后右边空出来的用0补充，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(5 &lt;&lt; 2);//输出20</div><div class="line">System.out.println(-5 &lt;&lt; 2);//输出-20</div></pre></td></tr></table></figure>
<p>左移原理如下：<br><img src="http://oppqlui3e.bkt.clouddn.com/%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97.png" alt=""></p>
<p>　　Java的右移运算符有两个 <strong>&gt;&gt;、&gt;&gt;&gt;</strong>，对于 <code>&gt;&gt;</code>运算符而言，把第一个操作数的二进制码右移指定位数后，左边空出来的为以原来的符号位填充，即如果是一个整数则以0补充，如果第一个操作数是负数则补1。 <code>&gt;&gt;&gt;</code>把第一个操作数右移指定位数后总以0补充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(5 &gt;&gt; 2);//输出-2</div><div class="line">System.out.println(-5 &gt;&gt;&gt; 2);//输出1073741822</div></pre></td></tr></table></figure>
<p><strong>-5&gt;&gt;2的运算原理</strong>：<br><img src="http://oppqlui3e.bkt.clouddn.com/-5%E5%8F%B3%E7%A7%BB2%E4%BD%8D.png" alt=""></p>
<p><strong>-5&gt;&gt;&gt;2的运算原理</strong>:</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/-5%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB.png" alt=""></p>
<p>注意： <strong>进行移位运算不会改变操作数本身，只是得到一个新的运算结果，原来的操作数本身不会改变</strong>。</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><hr>
<p>比较运算符用于判断两个变量或常量的大小，其结果是一个布尔值（true或false），如下：</p>
<ul>
<li>＞：大于，（只支持数值类型）</li>
<li>＞=：大于等于，（只支持数值类型）</li>
<li>&lt;：小于，（只支持数值类型）</li>
<li>&lt;=：小于等于，（只支持数值类型）</li>
<li>==：等于， 如果两边都是数值类型，即使它们数据类型不同，只要值相等也会返回true。如果两边是引用类型， <strong>只有当两个引用变量具有父子关系时才可比较</strong>，同时，这两个变量必须指向 <strong>同一个对象</strong>才会返回true。</li>
<li>!=：不等于，（同==）</li>
</ul>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><hr>
<p>用于操作两个布尔类型的变量或常量，如下：</p>
<ul>
<li>&amp;&amp;：与，两边为true时返回true</li>
<li>&amp;： 不短路与，（同&amp;&amp;）但不会短路</li>
<li>||：或，两边有一个为true返回true</li>
<li>|： 不短路或</li>
<li>!： 非，只有一个操作数，为true返回false</li>
<li>^ ：异或，两边结果不同时返回true，相同返回false</li>
</ul>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><hr>
<p>三目运算符只有一个：（？：）</p>
<p>格式为：(expression) ? if-true-statement : if-false-statment;</p>
<h4 id="运算符结合性和优先级"><a href="#运算符结合性和优先级" class="headerlink" title="运算符结合性和优先级"></a>运算符结合性和优先级</h4><hr>
<p><strong>单目运算符、赋值运算符、三目运算符</strong>是 <strong>从右向左</strong>运算的。</p>
<p>下表为运算符优先级表，上一行优先于下一行。</p>
<p><img src="http://oppqlui3e.bkt.clouddn.com/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据类型和运算符&quot;&gt;&lt;a href=&quot;#数据类型和运算符&quot; class=&quot;headerlink&quot; title=&quot;数据类型和运算符&quot;&gt;&lt;/a&gt;数据类型和运算符&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;本章主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本类型的转换&lt;/li&gt;
&lt;li&gt;直接量&lt;/li&gt;
&lt;li&gt;运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基本类型的类型转换&quot;&gt;&lt;a href=&quot;#基本类型的类型转换&quot; class=&quot;headerlink&quot; title=&quot;基本类型的类型转换&quot;&gt;&lt;/a&gt;基本类型的类型转换&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;Java语言所提供的7中数值类型之间可以相互转换，有两种转换方式： &lt;strong&gt;自动类型转换、强制类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;自动类型转换&quot;&gt;&lt;a href=&quot;#自动类型转换&quot; class=&quot;headerlink&quot; title=&quot;自动类型转换&quot;&gt;&lt;/a&gt;自动类型转换&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;　　当把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，西东可以自动类型转换，反之，则需要强制转换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oppqlui3e.bkt.clouddn.com/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%9B%BE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据类型转换" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Java基础原理笔记(一)</title>
    <link href="http://yoursite.com/2016/09/10/Java%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/09/10/Java基础原理笔记（一）/</id>
    <published>2016-09-10T07:06:55.000Z</published>
    <updated>2017-05-11T08:32:55.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java数据类型介绍"><a href="#Java数据类型介绍" class="headerlink" title="Java数据类型介绍"></a>Java数据类型介绍</h2><p><strong>本章主要内容</strong></p>
<ul>
<li>数据类型分类</li>
<li>基本数据类型</li>
</ul>
<hr>
<h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><p>Java语言是强类型（strongly typed）语言，强类型包含两方面的含义：</p>
<ul>
<li>所有的变量必须先声明、后使用。</li>
<li>指定类型的变量只能接受类型与之匹配的值。</li>
</ul>
<p>在了解数据类型前先弄懂两个问题：</p>
<h4 id="什么是变量？变量有什么用？"><a href="#什么是变量？变量有什么用？" class="headerlink" title="什么是变量？变量有什么用？"></a>什么是变量？变量有什么用？</h4><p>　　 <strong>编程的本质，就是对内存中的数据的访问和修改</strong>。程序所用的数据都会保存在内存中，程序员需要一种机制来访问或修改内存中的数据。这种机制就是 <strong>变量</strong>。每个变量都代表某一小块内存，而且变量是有名字的，程序对变量赋值， <strong>实际上就是把数据装入该变量所代表的内存区的过程</strong>；<br>程序读取变量的值， <strong>实际上就是从该变量所代表的内存区中取值的过程</strong>。 <strong>变量相当于一个有名称的容器，该容器用于装各种不同类型的数据</strong>。<br><a id="more"></a></p>
<p>Java语言支持的类型分为两种： <strong>基本类型</strong>和 <strong>引用类型</strong>。</p>
<p><strong>基本类型</strong>包括Boolean类型和数值类型。数值类型有整数类型和浮点类型。</p>
<p>整数类型包括： <strong>byte</strong>、 <strong>short</strong>、 <strong>int</strong>、 <strong>long</strong>、 <strong>char</strong></p>
<p>浮点类型包括： <strong>float</strong>和 <strong>double</strong></p>
<p>注意：char代表字符型，实际上字符型也是一种 <strong>整数类型</strong>，相当于 <strong>无符号整数类型</strong>。</p>
<p><strong>引用类型</strong>包括 <strong>类、接口、数组类型</strong>，还有一种特殊的 <strong>null类型</strong>。</p>
<p>引用类型就是对一个对象的引用，对象包括实例和数组两种。实际上，引用类型变量就是一个指针。</p>
<h3 id="数据基本类型"><a href="#数据基本类型" class="headerlink" title="数据基本类型"></a>数据基本类型</h3><p><img src="http://oppqlui3e.bkt.clouddn.com/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png?imageView2/2/00/h/200/q/75|imageslim" alt=""></p>
<p>Java中只包含这八种基本类型， <strong>字符串不是基本数据类型</strong>，字符串是一个类，即为一个引用数据类型。</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>int 是最常用的整数类型，因此直接给出一个整数值默认就是int类型。</p>
<p>如果直接将一个较小的整数值（在byte或short类型的表数范围内）赋给一个byte或short变量系统会自动把这个整数值当成byte/short类型来处理。但是使用一个很大的整数，Java不会把它当成long类型处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//系统不会把99999999999999999当成long类型处理,超出了int范围，引起错误</div><div class="line">long bg=99999999999999999;</div><div class="line">//应该在巨大整数值后使用L后缀，强制使用long类型</div><div class="line">long bg=99999999999999999L;</div></pre></td></tr></table></figure>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>字符型值有三种表现形式</p>
<ul>
<li>通过单个字符指定字符型值，如’A’, ‘1’。</li>
<li>通过转义字符表示特殊字符型值，如’\n’、 ‘\t’。</li>
<li>直接用Unicode值来表示字符型值’\uXXXX’， 其中XXXX代表一个十六进制的整数。<br><img src="http://oppqlui3e.bkt.clouddn.com/%E5%B8%B8%E7%94%A8%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png?imageView2/2/w/700/h/200/q/75|imageslim" alt=""></li>
</ul>
<p><strong>什么是字符集？</strong></p>
<p>　　给所有字符的编号组成综合。早期只要一个字节（8位）即可支持256个字符编号，就是ASCII字符集。后来又为所有的书面语言字符进行统一编号，使用2个字节（16位）支持65536个字符，这就是Unicode字符集。</p>
<p>由于计算机底层保存字符时， <strong>实际保存该字符对应的编号</strong>，因此char类型的值可直接作为整形值来使用，它相当于一个16位无符号整数，范围是0~65535。可以参与数学运算。</p>
<p><strong>用法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class CharTest</div><div class="line">&#123;</div><div class="line">	public static void main(String[] args)</div><div class="line">	&#123;</div><div class="line">		char xiang= &apos;\u9999&apos;;</div><div class="line">		//将输出&apos;香&apos;字</div><div class="line">		 System.out.println(xiang);</div><div class="line">		//直接把一个0~65535内的int整数赋给一个char变量</div><div class="line">		char a = 12;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>浮点型有两种： <strong>float、double</strong></p>
<p>它们有固定的表数范围和字段长度，字段长度和表数范围与机器无关，遵循IEEE754标准。采用 <strong>二进制</strong>数据的 <strong>科学计数法</strong>来表示浮点数。</p>
<p><strong>float型</strong></p>
<p>单精度浮点数，占4字节、32位</p>
<p>第1位是符号位，接下来8为表示指数，在接下来23为表示尾数</p>
<p><strong>double型</strong></p>
<p>双精度浮点数，占8字节、64位</p>
<p>第1位是符号位，接下来11为表示指数，在接下来52为表示尾数</p>
<p><strong>十进制形式</strong>：5.22、52.0 （必须包含一个小数点，否则会被当成int类型处理）</p>
<p><strong>科学计数法</strong>： 5.2e2 或 5.2E2 (即5.2*10^2)</p>
<p>Java中浮点类型默认为double型，如果希望把一个浮点类型值当做float型来处理应在这个浮点类型值后紧跟f或F。</p>
<p>Java中有三个特殊的浮点数值： <strong>正无穷大(POSITIVE_INFINITY)、负无穷大(NEGATIVE_INFINITY)、非数(NaN)</strong>。</p>
<p>正无穷大和正无穷大相等、负无穷大和负无穷大相等、NaN和谁都不相等（包括和NaN）。 <strong>只有浮点数</strong>除0才可以得到正负无穷大，因为Java会自动把浮点数运算的0当成0.0来处理，如果一个整数除以0，则会抛出异常：ArithmeticException：/by zero</p>
<h4 id="数值中使用下划线"><a href="#数值中使用下划线" class="headerlink" title="数值中使用下划线"></a>数值中使用下划线</h4><p>可以在任意数值中自由的使用下划线，通过下划线可以更直观的分辨数值中包含多少位。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int binVal = 0B1000_0000_0000_0000_0000_0000_0011;</div><div class="line">double pi = 3.14_15_926_53_59;</div></pre></td></tr></table></figure>
<h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>布尔型只有一个Boolean类型，用于表示逻辑上的“真”或“假”。值只能是 <strong>TRUE</strong>或 <strong>FALSE</strong>。其他的基本数据类型也不能转化成Boolean类型。</p>
<p>布尔类型主要用于流程控制</p>
<ul>
<li>if条件控制语句</li>
<li>while循环控制语句</li>
<li>do循环控制语句</li>
<li>for循环控制语句</li>
</ul>
<p>布尔类型的变量还可用在三目运算符（？：）中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java数据类型介绍&quot;&gt;&lt;a href=&quot;#Java数据类型介绍&quot; class=&quot;headerlink&quot; title=&quot;Java数据类型介绍&quot;&gt;&lt;/a&gt;Java数据类型介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本章主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据类型分类&lt;/li&gt;
&lt;li&gt;基本数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;数据类型分类&quot;&gt;&lt;a href=&quot;#数据类型分类&quot; class=&quot;headerlink&quot; title=&quot;数据类型分类&quot;&gt;&lt;/a&gt;数据类型分类&lt;/h3&gt;&lt;p&gt;Java语言是强类型（strongly typed）语言，强类型包含两方面的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的变量必须先声明、后使用。&lt;/li&gt;
&lt;li&gt;指定类型的变量只能接受类型与之匹配的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在了解数据类型前先弄懂两个问题：&lt;/p&gt;
&lt;h4 id=&quot;什么是变量？变量有什么用？&quot;&gt;&lt;a href=&quot;#什么是变量？变量有什么用？&quot; class=&quot;headerlink&quot; title=&quot;什么是变量？变量有什么用？&quot;&gt;&lt;/a&gt;什么是变量？变量有什么用？&lt;/h4&gt;&lt;p&gt;　　 &lt;strong&gt;编程的本质，就是对内存中的数据的访问和修改&lt;/strong&gt;。程序所用的数据都会保存在内存中，程序员需要一种机制来访问或修改内存中的数据。这种机制就是 &lt;strong&gt;变量&lt;/strong&gt;。每个变量都代表某一小块内存，而且变量是有名字的，程序对变量赋值， &lt;strong&gt;实际上就是把数据装入该变量所代表的内存区的过程&lt;/strong&gt;；&lt;br&gt;程序读取变量的值， &lt;strong&gt;实际上就是从该变量所代表的内存区中取值的过程&lt;/strong&gt;。 &lt;strong&gt;变量相当于一个有名称的容器，该容器用于装各种不同类型的数据&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
